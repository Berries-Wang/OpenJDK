# 02.Java及时编译器原理解析及实战
## 背景
&nbsp;&nbsp;为了优化Java的性能，JVM解释器之外引入了即时（Just In Time）编译器：当程序运行的时，解释器首先发挥作用，代码可以直接运行.随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化为本地代码，来获取更高的执行效率。解释器这时候可以**作为编译运行的降级手段**,在一些不可靠的编译优化出现问题的时候，再切换为解释执行，保证程序可以正常运行。
&nbsp;&nbsp;即时编译器极大提高了Java程序的运行速度，而且和静态编译相比，即时编译器可以选择性的编译热点代码，省去了很多编译时间，也节省了很多空间。
   - 即： 代码优先解释执行  -> 即时编译器优化之后，本地代码执行 -> 当出现编译优化问题时，回到解释执行
## Java的执行过程
&nbsp;&nbsp;Java的执行过程可以分为两个部分：
1. 第一步由javac将源代码便以为字节码，在这个过程中会进行 词法分析、语法分析、语义分析，编译原理中这部分编译称为**前端编译**。
2. 接下来并不需要编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，即时编译器会逐渐发挥作用，他会进行**后端编译**---即将字节码编译为机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码才可能被编译。
    - 遗留的一个问题? 什么是热点代码
       + 见 附录-01
## 01. JVM中的JIT(即时编译器)
&nbsp;&nbsp;JVM中集成了两种编译器，Client Compiler 和 Server Compiler，他们的作用也不一样。
   - Client Compiler注重启动速度和局部的优化
   - Server Compiler则更加注重全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。
&nbsp;&nbsp;两种编译器有着不同的应用场景，在虚拟机中同时发挥作用
### 01-01.Client Compiler(客户端编译器)
- <img src="./images/JIT-002.png">
&nbsp;&nbsp;HotSpot VM带有一个Client Compiler ，简称为C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做以下三件事:
1. 局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。
2. 将字节码构造成高级中间表示(High-level Intermediate Representation，以下称为HIR),HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化
3. 最后将HIR转换为低级中间表示(Low-level Intermediate Representation，以下称为LIR),在LIR的基础上会进行寄存器分配、窥孔优化(局部的优化方式，编译器在一个基本块或者多个基本块中，针对于已经生成的代码，集合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令的转换，来提升代码性能)等操作,最终生成机器码。

### 01-02.Server Compiler(服务端编译器)
&nbsp;&nbsp;Server Compiler主要关注一些编译比较耗时的全局优化，甚至还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，他的性能通常比Client Compiler高30%以上。目前，在HotSpot虚拟机中使用的Server Compiler有两种：
- C2
- Graal
#### 01-02-1. C2
&nbsp;&nbsp;在HotSpot VM中，默认的Server Compiler是C2编译器。
&nbsp;&nbsp;C2编译器在进行编译优化的时候，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤(尤其涉及到浮动代码块的那些优化步骤)变得不那么复杂。
+ Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，例如 Global Value Number 、 常量折叠等，解析结束之后，还会进行对一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序的运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。
&nbsp;&nbsp;无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后，编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。Server Compiler 编译优化步骤如下图所示:
   - <img src="./images/JIT-003.png">
### 01-02-2. Graal Compiler
&nbsp;&nbsp;从JDK9开始，HotSpot VM中集成了一种新的Server Compiler，Graal 编译器。相比于C2编译器，Graal有如下几种关键特性:
1. 如前所述，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，例如分支预测，根据程序不同分支的运行频率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常比C2更好。
2. 使用Java编写，对于Java语言，尤其是新特性，比如 Lambda，Stream更加友好。
3. 更深层次的优化，例如虚函数的内联，部分逃逸分析等。
&nbsp;&nbsp;Graal编译器可以通过java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，他将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。

## 02. 分层编译
+ 始于 Java 7
&nbsp;&nbsp;在Java 7以前，需要研发人员根据服务的特性去选择编译器，对于需要快速启动的，或者一些不会长时间运行的服务，可以采取编译效率较高的C1，对应参数 -client;长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数 -server。Java 7 开始引用了分层编译的概念，他结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了5个层次，分别是：
1. 层次一： 解释执行
2. 层次二： 执行不带profiling的C1代码
3. 层次三： 执行仅带方法调用次数以及循环回边执行次数的profiling的C1代码
4. 层次四： 执行带所有的profiling的C1代码
5. 层次五： 执行C2代码

### 什么是profiling ?
- profiling就是收集能够反映程序运行状态的数据。其中最基本的统计数据就是方法的调用次数以及循环回边的执行次数。
### 分层编译执行流程
&nbsp;&nbsp;通常情况下，C2代码的执行效率要比C1代码高出30%以上，C1层执行的代码，按执行效率排序从高至低： 1层 > 2层 > 3层(这里的**层**是指下面图中的层)。在这5个层次中，1层和4层都是终止状态，当一个方法达到终止状态后，只要编译后的代码没有失效，那么JVM就不会再次发出该方法的编译请求。服务实际运行时，JVM会根据服务的运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图就列举了几种常见的编译路径：(从下图也可以看出,JVM对字节码代码的执行过程)
- <img src="./images/JIT-004.webp"/>
  - 图中第1条路径(即1common,圆圈打不出来)，代表的一般情况，热点方法从解释执行到被三层的C1编译，最后到被4层的C2编译。
  - 如果方法比较小（比如常见的getter setter方法）,3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行途中第2条（2trivial method）路径。在这种情况下，JVM会在3层编译后，放弃进入C2编译，直接使用1层的C1编译运行。
  - 在C1忙碌的时候，执行途中第3条(3C1 busy)路径，在解释执行的过程中对程序进行profiling，根据信息直接由第4层的C2编译。
  - 前文提到C1的执行效率是 1层 > 2层 > 3层，3层一般比2层慢35%以上，所以在C2忙碌的时候，执行图中第4条路径。此时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。
  - 如果编译器做了一些比较激进的优化，例如分支预测，在实际运行时发现预测出错，此时就会进行反优化，重新进入解释执行，图中第5条执行路径代表的就是反优化。
总的来说，C1的编译速度更快，C2的编译质量越高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡的一个过程，从JDK8开始，JVM默认开启分层编译。
## 03 即时编译的触发
&nbsp;&nbsp;Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单地理解为往回跳转的指令，如下面这段代码:



## 附录
### 01.什么是热点代码
&nbsp;&nbsp;怎么样才会被认定为是热点代码呢? JVM中会设置一个阈值，当方法或者代码块在一段时间内的调用次数超过这个阈值就会被编译，**存入codeCache**中。当下次执行时，在遇到这一段代码,就会**从codeCache中读取机器码**,直接执行，以此来提升程序运行的性能。整个执行过程大致如下:
  - <img src="./images/JIT-001.png"/>
