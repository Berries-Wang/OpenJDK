# 批量重偏向和批量撤销

## 批量重偏向
&nbsp;&nbsp;批量重偏向：当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到 safe point 时将偏向锁撤销并升级。而偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM 中增加了一种批量重偏向机制。它主要是为了解决如下问题：一个线程 A 创建了大量锁对象并执行了初始的同步操作，此时线程 A 是偏向锁的持有者，但是之后线程 A 不再使用该锁，而是另一个线程 B 期望持有这些锁对象并进行之后的所有操作。在这种情况下，按照正常的逻辑，所有的偏向锁都会被撤销并升级为轻量级锁，这样即便是之后总是线程 B 一个线程使用这些锁，也不能享受到偏向锁的性能优势了。怎么解决这个问题呢？JVM 会以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，每当该 class 的任意实例对象发生偏向撤销操作时，该 class 的计数器 +1。当达到阈值（20）时，JVM 就会进行批量重偏向。当发生重偏向时，会更新 class 的 epoch 和 当前处于加锁状态的对象的 epoch，注意：对象在创建出来时，会复用其 class 当前的 epoch 值，而在发生批量重偏向时，只有真正处于锁定状态的对象 epoch 才会和 class 的 epoch 一起 +1，而不处于锁定状态的对象 epoch 不变（即线程栈中不存在对应 Lock Record 的锁对象）。这时候，如果线程 B 想要持有锁对象时，如果发现对象的 epoch 和其 class 的epoch 不等，可以不执行偏向锁撤销的逻辑，直接将 mark word 中的 thread id 通过 CAS 改为自己的 thread id。这样就避免偏向锁撤销的性能损耗，并且继续享受偏向锁带来的性能优势。

---

## 批量撤销
&nbsp;&nbsp;批量撤销：如果一些锁存在明显的多线程竞争，那么每个锁对象都要从偏向锁逐步升级到轻量级锁，显然会造成很大的性能损耗，所以，JVM 引入了一个直接跳过偏向锁的机制。就想批量重偏向时所说的，每个 class 都有一个计数器，该计数器在 class 对象发生偏向锁撤销时 +1，当该计数器达到更高阈值（40）时，JVM 会认定该 class 存在明显的竞争，不适合使用偏向锁，之后该 class 的所有对象都不再使用偏向锁，而是直接使用轻量级锁。

---
## JVM参数
1. BiasedLockingBulkRebiasThreshold : 重偏向阈值，达到了这个阈值，就进行批量重偏向
2. BiasedLockingBulkRevokeThreshold : 重偏向阈值，达到了这个阈值，之后，对于该class，直接走轻量级锁的逻辑