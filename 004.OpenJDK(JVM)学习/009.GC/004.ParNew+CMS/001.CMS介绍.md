# CMS(Concurrent Mark-Sweep ` 并发低停顿收集器)
&nbsp;&nbsp;CMS收集器是一种以获取最短回收停顿时间为目标的收集器。互联网网站或者基于B/S系统的服务器这类应用通常较为关注服务器的响应速度，希望系统的停顿时间尽可能短，给用户带来较好的体验，CMS收集器就非常符合这类应用的需求。

&nbsp;&nbsp;CMS收集器是基于标记(Mark)-清理(Sweep)算法，整个过程分为如下几步:
1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

&nbsp;&nbsp;初始标记、重新标记需要STW(Stop The World)：
+ 初始标记: 仅标记GC Roots能直接关联到的对象，速度快
+ 并发标记： 从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时长，但是并不需要停止用户线程，用户线程可以与垃圾收集线程并发执行。
+ 重新标记： 修正并发标记期间，因用户线程运作而导致标记产生变动的那一部分对象的标记记录(**增量更新**，见[005.可达性分析算法.md](../005.可达性分析算法.md))
+ 并发清除： 清理删除掉标记阶段判断的已经死亡的对象，这个不需要移动存活对象，因此这个阶段也是可以和用户线程并发执行.

## 缺点
### 1. 处理器资源敏感
&nbsp;&nbsp;面向并发设计的程序都对处理器资源比较敏感。在并发阶段，虽然不会导致用户线程停顿，但是会因为占用一部分线程(CPU的计算能力)而导致应用程序变慢，降低吞吐率。

### 2. 产生浮动垃圾
&nbsp;&nbsp;CMS收集器无法处理"浮动垃圾"，有可能出现"Concurrent Mode Failure"失败而导致另一次完全 "Stop The World"的Full GC的产生.

&nbsp;&nbsp;浮动垃圾: 在CMS的并发标记和并发清理阶段，用户线程还在继续运行，程序在运行期间自然就会伴随着新的垃圾对象的产生，但这一部分垃圾对象是出现在标记过程结束之后，CMS无法在当次收集中处理掉他们，只能留到下一次垃圾收集时再清理掉。
> 因为在垃圾收集阶段用户线程还需要持续运行，所以还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。

> JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。可以调整参数: -XX:CMSInitiatingOccu-pancyFraction 的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。

> JDK1.6时，CMS收集器的启动阈值已经提升到92%,但也面临着另一种风险: Concurrent Mode Failure: CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现并发失败(Concurrent Mode Failure).
> > 预备方案: 冻结用户线程，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间久很长了。

### 3. 产生空间碎片
&nbsp;&nbsp;CMS是基于标记-清除 算法实现的收集器，这意味着收集结束时会有大量的空间碎片产生。空间碎片过多，将会给大对象分配带来很大麻烦。