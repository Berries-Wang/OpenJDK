# OopMap
&nbsp;&nbsp;在HotSpot中，有个数据结构（映射表）称为「OopMap」。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在「特定的位置」生成 OopMap，记录下栈上和寄存器里哪些位置是引用。
- 在解释执行时就没有必要生成OopMap了，因为此时本地变量表都是已知的，可以直接添加到GC Roots中.
## 功能
&nbsp;&nbsp;OopMap 记录了栈上本地变量到堆上对象的引用关系。
### 区分Oop
&nbsp;&nbsp;在垃圾回收时如何区分一个立即数和指针地址? 如从Java的根集合中发现有一个值(0X12345678)，那么这个数到底是一个整数还是一个Java对象的地址?实际上垃圾收集器并不能区分，但是为了准确的回收垃圾，必须区分出来。一个简单的办法： 将0X12345678先看成一个地址，即强制转换为OOP结构，再判定这个OOP是否含有Klass指针，有则认为是一个指针，如果是NULL则认为是一个立即数。此时会有一个误判：
+ 误判: 当这个立即数刚好和一个OOP地址相同时，会将这个立即数误认为是一个OOP
    - 解决方案: JVM维护了一个全局的OopMap,用于记录栈里面的数是立即数还是值。每个InstanceKlass都维护了一个Map(OopMapBlock)用于标记Java类里面的字段是Oop还是int这样的立即数。

&nbsp;&nbsp;即GC是从根集合出发开始标记，通过外部的数据结构来标识是否为Oop。

## From DeepSeek
### OopMap 在 JVM 中的作用

OopMap（Object-Oriented Pointer Map）是 JVM 中一种重要的数据结构，主要用于垃圾收集（GC）过程中的准确式垃圾收集（Accurate GC）。

#### 什么是 OopMap

OopMap 是一种记录栈帧或寄存器中哪些位置包含对象引用（OOP，Ordinary Object Pointer）的映射表。它告诉垃圾收集器在执行 GC 时，从哪里可以找到所有的对象引用。

#### OopMap 的主要用途

1. **快速根节点枚举**：在 GC 根节点枚举时，不需要扫描整个栈和寄存器，只需查看 OopMap 即可知道哪些位置存放着引用。

2. **安全点（Safepoint）优化**：JVM 只在特定位置（如方法调用、循环跳转等）生成 OopMap，这些位置称为安全点。

3. **减少 GC 停顿时间**：通过预先生成的 OopMap，GC 可以快速定位所有引用，而不需要全栈扫描。

## OopMap 的实现特点

- 通常在编译期间由 JIT 编译器生成
- 存储在方法的方法表中
- 只记录安全点位置的引用信息
- 使用位图或类似紧凑格式存储以节省空间

#### 示例

假设在某方法的安全点处，栈帧中有以下引用：
- 局部变量1：对象引用
- 局部变量3：对象引用
- 表达式栈顶：对象引用

对应的 OopMap 可能会记录这些位置的信息，使得 GC 可以快速找到这些引用而不需要扫描整个栈帧。

OopMap 是现代 JVM 实现高效垃圾收集的关键技术之一，它使得停顿时间较短的垃圾收集器（如 CMS、G1）成为可能。

---
## From ChatGPT
在 JVM 中，`OopMap`（Object Pointer Map）是一种数据结构，用于表示栈帧中的对象引用的位置。它主要用于垃圾回收（GC）时的对象引用跟踪。具体来说，`OopMap` 描述了一个栈帧中哪些位置包含指向 Java 对象的引用，以及这些引用的位置。

### 背景

在 JVM 执行过程中，每个线程会在堆栈上推入栈帧，每个栈帧中包含局部变量、操作数栈、以及用于方法执行的其他数据。对于垃圾回收来说，它需要了解堆栈上的哪些位置存储的是对象引用，因为垃圾回收器需要知道哪些对象是被活跃线程引用的，以便决定哪些对象应该被保留，哪些可以被回收。

**`OopMap`** 的作用就是在执行某些操作（例如方法调用）时，帮助记录并标识栈中哪些位置是对象引用。这对于垃圾回收非常重要，特别是在**并发垃圾回收**（例如并行 GC 或并发标记扫描）中，垃圾回收器需要准确地知道哪些栈变量引用了堆中的对象。

### OopMap 的作用

1. **垃圾回收时跟踪引用**：`OopMap` 描述了栈帧中的哪些位置可能包含指向堆上对象的引用。垃圾回收器可以通过 `OopMap` 知道哪些栈位置需要被扫描，从而确定哪些对象是活动的（被引用的）。
   
2. **栈扫描**：在进行垃圾回收时，垃圾回收器会扫描每个栈帧的 `OopMap`，查看栈中哪些位置包含指向堆上对象的引用。如果一个位置标记为“含有对象引用”，垃圾回收器会将该位置的内容作为指向堆对象的指针进行扫描。

3. **增强并发性和准确性**：在并发垃圾回收（如 CMS 和 G1）中，`OopMap` 允许 JVM 在不暂停应用程序执行的情况下扫描栈中的对象引用。通过准确标记栈中的对象引用，垃圾回收器可以在应用程序继续执行时进行有效的垃圾回收。

### OopMap 的结构

`OopMap` 是在编译阶段由 **JIT 编译器**生成的。它通常以二进制格式存储在字节码中，并与栈帧一起管理。`OopMap` 通过以下方式表示栈中对象的引用：

- **标记栈位置**：在栈帧中，每个局部变量、操作数栈等位置会有一个标记，指示该位置是否包含对象引用。
- **索引到对象**：`OopMap` 还可以标记哪些对象引用是在特定的栈位置。如果某个栈位置存储着一个指向对象的引用，`OopMap` 就会记录这个引用。

在 JVM 执行时，垃圾回收器通过 `OopMap` 来识别哪些栈帧的内容需要被扫描。通过这种方式，JVM 可以在不停止程序执行的情况下，确保活动对象的正确标记和回收。

### 在 JVM 中的工作流程

1. **方法调用**：当一个方法被调用时，它会在栈上分配一个新的栈帧。JVM 会根据当前方法的字节码生成相应的 `OopMap`。
   
2. **生成 OopMap**：JIT 编译器在编译过程中会为每个方法的每个栈帧生成一个 `OopMap`，指示栈帧中哪些位置保存了对象引用。

3. **GC 时的作用**：当垃圾回收器运行时，它使用这些 `OopMap` 来扫描栈帧，确定哪些位置保存了指向堆中对象的引用。垃圾回收器根据这些信息来标记活跃对象并执行回收。

4. **并发垃圾回收**：在并发垃圾回收过程中，JVM 会利用 `OopMap` 在不暂停应用程序的情况下扫描栈中的对象引用，从而实现对堆上对象的有效管理。

### OopMap 示例

以下是一个简化的示例，假设有一个栈帧，其中包含几个局部变量和操作数栈：

```java
void exampleMethod() {
    Object obj1 = new Object();  // 对象引用
    Object obj2 = new Object();  // 对象引用
    int num = 42;                // 普通整数值
}
```

在这个方法中，`obj1` 和 `obj2` 是对象引用，`num` 是一个普通的整数。为了帮助垃圾回收器确定哪些栈位置包含对象引用，JVM 会在栈帧中生成一个 `OopMap`，表示哪些位置保存了对象引用。假设 `OopMap` 如下所示：

- `位置 0`: `obj1` 是对象引用
- `位置 1`: `obj2` 是对象引用
- `位置 2`: `num` 是普通值（非对象引用）

在垃圾回收时，JVM 会根据这个 `OopMap` 知道它需要扫描的位置，查找并跟踪这些对象引用。

### 总结

`OopMap` 在 JVM 中扮演了重要的角色，主要用于垃圾回收时跟踪堆栈中的对象引用。它帮助 JVM 在执行期间标识哪些栈位置包含指向对象的引用，从而确保垃圾回收的正确性和效率。在并发垃圾回收机制中，`OopMap` 的作用尤其关键，能够在不中断应用程序执行的情况下进行有效的垃圾回收。

---
## 参考资料
+ 《JVM G1源码分析与调优》 P27
+ [https://stackoverflow.com/questions/26029764/what-does-oop-maps-means-in-hotspot-vm-exactly](https://stackoverflow.com/questions/26029764/what-does-oop-maps-means-in-hotspot-vm-exactly)
+ [https://bbs.huaweicloud.com/blogs/139877](https://bbs.huaweicloud.com/blogs/139877)