# JVM引用
&nbsp;&nbsp;请参考:[005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/jdk/src/share/classes/java/lang/ref/Reference.java](../../005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/jdk/src/share/classes/java/lang/ref/Reference.java)
> 需要注意的是： Reference 各个成员属性的含义，以及与JVM GC线程的关系

&nbsp;&nbsp;引用，即如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据代表某块内存、某个对象的引用。

## JVM引用类型
&nbsp;&nbsp;下面讲述了JVM中的引用类型以及在Java中的存在形式以及回收策略等

&nbsp;&nbsp;列举顺序: 从上往下，引用强度越弱。
### 强引用
&nbsp;&nbsp;指在代码中普遍存在的引用赋值，即类似于"Object obj = new Object();"这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就不会回收掉被引用的对象。

### 软引用(Soft Reference)
&nbsp;&nbsp;软引用用来描述一些还有用，但是非必须的对象。只被软引用**关联**<sup>此时的关联有深意</sup>的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。如果这次还没有足够的内存，那么会抛出OOM异常。
- 关联这个词说明了对象和软引用之间的关系,如下代码:
 ```java
         SoftReference<Object> softReference = null;
        {
            // obj是强引用
            Object obj = new Object();

            System.out.println(obj.toString());

            // softReference 是弱引用,如下代码体现了弱引用和对象的关联关系
            softReference = new SoftReference(obj);
        }

        System.out.println(softReference.get().toString());

        // 软引用softReference关联的对象是obj. 即说明引用和对象之间的"关联"关系
 ```

#### 软引用在Java中的体现
- [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/SoftReference.java](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/SoftReference.java)
##### 软引用的回收策略
- 通过GC代码进行分析: 如[004.OpenJDK(JVM)学习/009.GC/006.VM_Operation.md](../../004.OpenJDK(JVM)学习/009.GC/006.VM_Operation.md),即通过 VM_GenCollectForAllocation 开始分析.
###### 软引用回收策略
+ 定义: 引用回收策略定义于文件: [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.hpp](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.hpp)中
###### 软引用处理
```c
   void ParNewGeneration::collect(bool   full,
                                  bool   clear_all_soft_refs,
                                  size_t size,
                                  bool   is_tlab)

       执行了方法: rp->process_discovered_references(&is_alive, &keep_alive,
                                            &evacuate_followers, NULL,
                                            _gc_timer);
       在ReferenceProcessor::process_phase1中应用了引用处理策略,但是引用处理策略是在其他地方设置的。如下代码
       // 摘自 005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/genCollectedHeap.cpp
       if (rp->discovery_is_atomic()) {
            rp->enable_discovery(true /*verify_disabled*/,
                                 true /*verify_no_refs*/);
            /**
             * 设置软引用处理策略，详细代码见:
             * hotspot/src/share/vm/memory/referenceProcessor.hpp
             * 注意，参数“do_clear_all_soft_refs” 影响着软引用清理策略的选择，详细的请参见代码
             */ 
            rp->setup_policy(do_clear_all_soft_refs);
          }

```

### 弱引用(Weak references)
&nbsp;&nbsp;弱引用也是用来描述那些非必须的对象，但是他的强度比软引用更若一些，被弱引用关联的对象只能生存到下一次GC发生之前。即当垃圾收集器开始工作，不论当前内存是否足够，都会回收掉只被若引用关联的对象。

#### 弱引用在Java中的体现
- [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/WeakReference.java](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/WeakReference.java)

### 虚引用(Final references)
&nbsp;&nbsp;虚引用也被称为 幽灵引用 或 幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过一个虚引用来获取一个对象实例。
> 为一个对象设置虚引用关联的唯一目的只是为了能够在这个对象被收集器回收时收到一个系统通知。


#### 虚引用在Java中的体现
- [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/FinalReference.java](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/jdk/src/share/classes/java/lang/ref/FinalReference.java)

---
## 软引用回收策略
#### ReferencePolicy(超类，不可直接使用)
&nbsp;&nbsp;共四种：
- NeverClearPolicy
  + 从不清理，即should_clear_reference返回false
- AlwaysClearPolicy
  + 总是清理，即should_clear_reference返回true
- LRUCurrentHeapPolicy
- LRUMaxHeapPolicy
  + LRUCurrentHeapPolicy 与 LRUMaxHeapPolicy 略有不同，具体看注释

&nbsp;&nbsp;具体实现请看如下文件，注释都有:
1. [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.hpp](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.hpp)
2. [005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.cpp](../../005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/share/vm/memory/referencePolicy.cpp)
---
### JVM引用类型和引用回收策略的关系
```c
   void ParNewGeneration::collect(bool   full,
                                  bool   clear_all_soft_refs,
                                  size_t size,
                                  bool   is_tlab);

      // 执行了方法: rp->process_discovered_references(&is_alive, &keep_alive,
                                             &evacuate_followers, NULL,
                                             _gc_timer);
      // 在ReferenceProcessor::process_phase1中应用了引用处理策略

       // 通过分析如上代码，可以发现，对于软应用，JVM使用了引用处理策略，对于其他引用类型，则没有使用引用策略。
       // 且 通过代码可以分析出 引用 和 对象 的关联关系，即对象和引用是两个东西。
       // 通过分析引用处理的阶段1(方法如下)，会发现，引用类型处理的是 Reference 子类实例，而不是强引用类型.

       void ReferenceProcessor::process_phase1(DiscoveredList&    refs_list,
                                   ReferencePolicy*   policy,
                                   BoolObjectClosure* is_alive,
                                   OopClosure*        keep_alive,
                                   VoidClosure*       complete_gc) ;
      
      // 如果关联对象存在强引用，则该引用对象还不允许回收；反之，该引用对象则根据相应的引用策略来进行处理。
```
---
## 参考资料
1. [https://docs.oracle.com/javase/10/gctuning/other-considerations.htm#JSGCT-GUID-A7B0991C-661F-47BE-AEDB-74C6BDBDE181](https://docs.oracle.com/javase/10/gctuning/other-considerations.htm#JSGCT-GUID-A7B0991C-661F-47BE-AEDB-74C6BDBDE181)
2. OpenJDK8