# OopMap
&nbsp;&nbsp;在HotSpot中，有个数据结构（映射表）称为「OopMap」。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在「特定的位置」生成 OopMap，记录下栈上和寄存器里哪些位置是引用。
- 在解释执行时就没有必要生成OopMap了，因为此时本地变量表都是已知的，可以直接添加到GC Roots中.
## 功能
&nbsp;&nbsp;OopMap 记录了栈上本地变量到堆上对象的引用关系。
### 区分Oop
&nbsp;&nbsp;在垃圾回收时如何区分一个立即数和指针地址? 如从Java的根集合中发现有一个值(0X12345678)，那么这个数到底是一个整数还是一个Java对象的地址?实际上垃圾收集器并不能区分，但是为了准确的回收垃圾，必须区分出来。一个简单的办法： 将0X12345678先看成一个地址，即强制转换为OOP结构，再判定这个OOP是否含有Klass指针，有则认为是一个指针，如果是NULL则认为是一个立即数。此时会有一个误判：
+ 误判: 当这个立即数刚好和一个OOP地址相同时，会将这个立即数误认为是一个OOP
    - 解决方案: JVM维护了一个全局的OopMap,用于记录栈里面的数是立即数还是值。每个InstanceKlass都维护了一个Map(OopMapBlock)用于标记Java类里面的字段是Oop还是int这样的立即数。

&nbsp;&nbsp;即GC是从根集合出发开始标记，通过外部的数据结构来标识是否为Oop。

## 参考资料
1. 《JVM G1源码分析与调优》 P27