# RSet与Refine线程
## RSet
&nbsp;&nbsp;RSet 是一个抽象概念，记录对象在不同代际之间的引用关系，目的是加速垃圾回收的速度。

### 背景
&nbsp;&nbsp;如何加速回收速度: JVM使用的是跟对象引用的收集算法，即从根集合出发，标记所有存活的对象，然后遍历对象的每一个成员变量并继续标记，知道所有的对象标记完毕。 但是在垃圾回收中，新生代和老年代处于不同的回收阶段，如果还是采用这样的标记方法，不合理也没有必要。如仅回收新生代，如果标记时把老生代的活跃对象全部标记，但回收时并没有回收老年代，则浪费了时间。同样的，在回收老年代时，当且仅当进行FGC时，才需要对内存进行全部标记。
> 在进行GC时，控制GC Roots的数量，避免做了无用功而造成时间的浪费。

### RSet
&nbsp;&nbsp;为了对这种情况进行优化，JVM引入了RSet,用于记录从非收集部分指向收集部分的指针的集合，而这个集合描述的就是对象的引用关系。

### 引用记录的方法
  ```txt
     ObjA.fieldA = ObjB;
  ```
&nbsp;&nbsp;如上伪代码，通常有两种引用记录方法：
1. Point Out: 会在ObjA的RSet中记录ObjB的地址;
   > 引用了谁
2. Point In: 会在ObjB的RSet中记录ObjA的地址;
   > 被谁引用了

&nbsp;&nbsp;Point Out记录简单，但是需要对RSet做全部扫描；Point In记录操作复杂，但是在标记扫描时可以直接找到有用和无用的对象，不需要进行额外的扫描，因为RSet中的对象可以看作为跟对象。
> G1中使用的记录方式: Point In

### RSet数据结构
&nbsp;&nbsp;G1中使用了Point In的记录方式，为了提高RSet的存储效率，使用了三种数据结构:
<img src="./pics/a6e147e116ee455eb53e0742d0500dcd.png"/>
1. 稀疏表，通过哈希表方式来存储
2. 细粒度表，通过数组来存储，每个数组元素指向引用者分区中512字节内存块对本分区的引用情况。
   ```c
      // 在细粒度表中，每一项都是PRT,这个PRT使用的是HeapRegion的起始地址加上一个位图，这个位图描述这一个分区的引用情况，所以他的大小为HeapRegionSize%
   ```
3. 粗粒度位图，通过位图来只是，每一位表示对应分区有引用到本分区。



## Refine线程
&nbsp;&nbsp;G1中引入了Refine线程，他实际上是一个线程池。有两大功能:
1. 用于处理新生代的抽样，并且在满足响应时间这个指标的情况下，更新新生代分区的数目，通常由一个单独的线程来处理。
2. 更新RSet
- 对于RSet的更新并不是同步完成的，G1会把所有的引用关系都先放到一个队列中(Dirty Card Queue,DCQ),然后使用Refine线程来消费这个队列完成引用关系的记录。正常来说有G1ConcRefinementThreads个线程处理，实际上除了Refine线程更新RSet之外，GC工作线程或者应用程序线程也可能会更新RSet.DCQ通过Dirty Card Queue Set(DCQS)来管理，为了能够快速、并发的处理，每个Refine线程只负责DCQS中某几个DCQ.

&nbsp;&nbsp;<font color="red">**RSet是为了记录对象在代际之间的引用**</font>,但是并不是所有代际之间的引用都需要记录。分区之间的应用关系可以归纳为:

|引用关系|是否需要记录|为什么|
|---|---|---|
|分区内部|不需要|回收是针对一个分区的，即这个分区要么被回收，要么不回收。如果回收，则会遍历整个分区。|
|新生代分区到新生代分区|不需要|G1的YGC/Mixed GC/FGC回收算法都会全量处理新生代分区，他们都会被遍历，因此无须记录|
|新生代分区到老年代分区|不需要|G1中的YGC针对的是新生代，无须知道这个引用关系；Mixed GC时，G1会使用新生代分区作为根，那么遍历新生代分区时自然能够找到新生代分区到老年代分区的引用，所以无须记录。|
|老年代分区到新生代分区|需要|在YGC时有两种根: 一个就是栈空间/全局变量的引用；一个是老生代分区的引用。|
|老年代分区到老年代分区|需要|在Mixed GC时可能只有部分分区被回收|

&nbsp;&nbsp;这里的引用关系指的是分区里面有一个对象存在一个指针指向另一个分区的对象。G1使用了RSet来记录所有的引用关系，单这并不是最优的设计方案。因为使用RSet进行回收实际上有两个重大的缺点:
1. 需要额外内存空间： 这一部分通常是JVM最大的额外开销，一般在1% ~ 20%
2. 可能导致浮动垃圾：由于根据RSet回收，而RSet里面的对象可能已经死亡，这个时候被引用对象会被认为是活跃对象，实际上他是浮动垃圾。

&nbsp;&nbsp;基于上述两点，有必要对RSet进行优化：
1. 通过垃圾回收的原理，可以判断哪些引用关系需要存放到RSet中。
--- 

## 开发选项
```c
   // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/gc_implementation/g1/g1_globals.hpp
     develop(bool, G1RecordHRRSOops,true,                    \
          "When true, record recent calls to rem set operations.")

     develop(bool, G1HRRSUseSparseTable, true,               \
          "When true, use sparse table to save space.")

     develop(bool, G1TraceHeapRegionRememberedSet,true,      \
          "Enables heap region remembered set debug logs")  
```
---
## 参考资料