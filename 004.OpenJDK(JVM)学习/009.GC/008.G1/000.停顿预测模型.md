# G1停顿预测模型
&nbsp;&nbsp;G1是响应时间优先的GC算法，用户可以设定整个GC过程的期望停顿时间，由参数MaxGCPauseMills控制，默认值是200ms。不过他不是硬性条件，只是期望值，G1会努力在这个目标停顿时间内完成垃圾收集动作。但他不能保证，也有可能完不成(如设置了太小的停顿时间，新生代太大等)
- 即期望停顿时间在 MaxGCPauseMills内

&nbsp;&nbsp;G1通过停顿预测模型统计计算出来的历史数据来预测本次收集需要选择的堆分区数量(即选择哪些内存空间)，从而尽量满足用户设定的目标停顿时间。G1的预测逻辑是基于衰减平均值和衰减标准差的。
- 根据预测模型来确定需要回收的Heap Region的数量
- 尽量满足用户期望的停顿时间，而不是说停顿时间一定在用户指定的范围内

## 源码分析
1. 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/utilities/numberSeq.hpp
2. 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/utilities/numberSeq.cpp
   - 方法: AbsSeq::add(double val)
3. 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/gc_implementation/g1/g1CollectorPolicy.hpp
   - 方法: get_new_prediction

## get_new_prediction 方法返回值是如何应用的?
### 并行标记
- 代码: 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/gc_implementation/g1/concurrentMarkThread.cpp#ConcurrentMarkThread::run()
- ```c
    if (!cm()->has_aborted()) {
          if (g1_policy->adaptive_young_list_length()) {
            double now = os::elapsedTime();
            // 预测本次并行标记阶段所耗费的时间
            double remark_prediction_ms = g1_policy->predict_remark_time_ms();
            jlong sleep_time_ms = mmu_tracker->when_ms(now, remark_prediction_ms);
            os::sleep(current_thread, sleep_time_ms, false);
          }

          if (G1Log::fine()) {
            gclog_or_tty->gclog_stamp(cm()->concurrent_gc_id());
            gclog_or_tty->print_cr("[GC concurrent-mark-end, %1.7lf secs]",
                                      mark_end_sec - mark_start_sec);
          }

          CMCheckpointRootsFinalClosure final_cl(_cm);
          VM_CGC_Operation op(&final_cl, "GC remark", true /* needs_pll */);
          VMThread::execute(&op);
        }
  ```

### 如何影响本次收集需要选择的堆分区数量呢?
&nbsp;&nbsp;目前仅知道G1停顿预测模型会影响本次需要GC的堆分区数量


---
## 参考资料
1. [Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)