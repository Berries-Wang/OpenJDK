# G1(Garbage-First Garbage Collector,垃圾优先型垃圾回收器)分区
&nbsp;&nbsp;传统的垃圾收集器将连续的内存空间划分为新生代、老年代以及永久代(JDK8去除了永久代，引入了元空间Metaspace),这种划分的特点是各代存储地址(逻辑地址)是连续的。如下图:
- <img src = "./pics/8a9db36e.png"/>

&nbsp;&nbsp;而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region,每个Region占有一块连续的虚拟内存地址。如下图:
- <img src = "./pics/8ca16868.png"/>

&nbsp;&nbsp;Heap Region(分区)，是G1和操作系统交互的最小管理单位，G1的分区类型(HeapRegionType)大致可以分为四类:
1. 自由分区(Free Heap Region,FHR)
2. 新生代分区(Young Heap Region,YHR)
3. 大对象分区(Humongous Heap Region,HHR)
4. 老年代分区(Old Heap Region,OHR)
5. ```c
      // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/gc_implementation/g1/heapRegionType.hpp

        typedef enum {
            FreeTag       = 0,
        
            YoungMask     = 2,
            EdenTag       = YoungMask,
            SurvTag       = YoungMask + 1,
        
            HumMask       = 4,
            HumStartsTag  = HumMask,
            HumContTag    = HumMask + 1,
        
            OldTag        = 8
        }Tag;
   ```

## HR大小如何设置?
&nbsp;&nbsp;<font color="red">**G1中每个分区大小是相同的**</font>,那么如何设置HR的大小呢?

&nbsp;&nbsp;HR的大小影响着分配和垃圾回收效率。
- 过大，一个HR上可以存放多个对象，分配效率高，但是垃圾回收时花费时间过长；
- 过小,则导致分配效率低下。

&nbsp;&nbsp;HR有一个上限值和一个下限值，值如下代码。HR大小可由以下方式确定:
1. 通过参数G1HeapRegionSize来指定大小，这个参数默认值为0
2. 启发式推断，即在不指定HR大小的时候，由G1启发式地推断HR大小。

### 设置HR大小源码分析
```c
   /**
    * 设置HR的大小
    * 
    * @param initial_heap_size 初始堆大小
    * @param max_heap_size 最大堆大小
    * 
    * 通过如下代码分析，region_size 最大值为32MB,最小值为1MB,且
    * region_size必须是2的整数次幂，因此，region_size的范围:[1MB,2MB,4MB,8MB,16MB,32MB]
    */ 
   void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
     // 读取VM参数G1HeapRegionSize，默认值为0
     uintx region_size = G1HeapRegionSize;
     // 即G1HeapRegionSize是否指定
     if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
       // 计算一个平均值
       size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
       /**
        * HeapRegionBounds::target_number(): 2048
        * HeapRegionBounds::min_size()： 1M
        */ 
       // 通过堆的大小计算HR的大小
       region_size = MAX2(average_heap_size / HeapRegionBounds::target_number(),
                          (uintx) HeapRegionBounds::min_size());
     }
   
     // 对数转换,即1*2^region_size_log<=region_size(这个小于是无限接近)
     int region_size_log = log2_long((jlong) region_size);
   
     /**
      *
      *  Recalculate the region size to make sure it's a power of
      * 2. This means that region_size is the largest power of 2 that's
      * <= what we've calculated so far.
      * 重新计算region_size,确保他是2整数次幂，即region_size 是最接近于上面计算的
      * region_size的2的整数次幂的一个整数。
      */
     region_size = ((uintx)1 << region_size_log);
   
     /**
      *  Now make sure that we don't go over or under our limits.
      *  确保region_size是规定的范围内
      */ 
     if (region_size < HeapRegionBounds::min_size()) {
       region_size = HeapRegionBounds::min_size();
     } else if (region_size > HeapRegionBounds::max_size()) {
       // HeapRegionBounds::max_size(): 32MB
       region_size = HeapRegionBounds::max_size();
     }
   
     // And recalculate the log. 重新计算一下对数,用于计算一些变量，如卡表大小
     region_size_log = log2_long((jlong) region_size);
   
     // Now, set up the globals.
     guarantee(LogOfHRGrainBytes == 0, "we should only set it once");
     LogOfHRGrainBytes = region_size_log;
   
     guarantee(LogOfHRGrainWords == 0, "we should only set it once");
     LogOfHRGrainWords = LogOfHRGrainBytes - LogHeapWordSize;
   
     guarantee(GrainBytes == 0, "we should only set it once");
     // The cast to int is safe, given that we've bounded region_size by
     // MIN_REGION_SIZE and MAX_REGION_SIZE.
     GrainBytes = (size_t)region_size;
   
     guarantee(GrainWords == 0, "we should only set it once");
     GrainWords = GrainBytes >> LogHeapWordSize;
     guarantee((size_t) 1 << LogOfHRGrainWords == GrainWords, "sanity");
   
     guarantee(CardsPerRegion == 0, "we should only set it once");
     CardsPerRegion = GrainBytes >> CardTableModRefBS::card_shift;
   }
    
```

---
## 参考资料
1. OpenJDK版本: [005.OpenJDK/002.OpenJDK8u312-GA](../../../005.OpenJDK/002.OpenJDK8u312-GA) 