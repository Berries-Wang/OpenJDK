# Mixed GC(混合GC)
&nbsp;&nbsp;Mixed GC 既回收YHR也回收OHR

&nbsp;&nbsp;混合回收主要分为两个阶段:
1. 并发标记
   - 主要是将垃圾较多的老年代分区加入到CSet Chooser中
2. 垃圾回收
   - 这个过程和新生代回收的步骤完全一样，重用了新生代回收的代码。

## 第一阶段: 并发标记
&nbsp;&nbsp;并发标记的目的是为了识别老生代分区的使用情况，在下一次回收的时候优先选择垃圾比较多的分区进行回收。
### 初始标记子阶段
&nbsp;&nbsp;负责标记所有直接可达的根对象(栈对象、全局对象、JNI对象等)，根是对象图的起点，因此初始标记需要将Mutator线程暂停，也就是需要一个STW时间段.

&nbsp;&nbsp;混合收集中的初始标记和新生代的初始标记几乎一样。实际上混合收集的初始标记是借助了新生代收集的结果，即新生代垃圾回收后的新生代Survivor分区作为根，<font color="red">所以混合收集一定发生在新生代回收之后，且不需要再进行一次初始标记。</font>


### 并发标记子阶段
&nbsp;&nbsp;在YGC之后，如果发现满足并发标记的条件，并发线程就开始进行并发标记。根据新生代的Survivor分区以及老生代的RSet开始并发标记。并发的时机是在YGC后，只有达到InitiatingHeapOccupancyPercent阈值后，才会触发并发标记。InitiatingHeapOccupancyPercent默认值是45,表示的是当已经分配的内存加上即将分配的内存超过内存总容量的45%就可以开始并发标记。

### 再标记子阶段
&nbsp;&nbsp;再标记是最后的一个标记阶段，在该阶段中，G1需要引入一个暂停的时间，找出所有未被访问的存活对象，同事完成存活内存数据计算。引入该阶段的目的，是为了能够达到结束标记的目标，要结束标记的过程，需要满足三个条件:
1. 从根(Survivor)出发，并发标记子阶段已经追踪了所有存活对象。
2. 标记栈是空的
3. 所有的引用变更都被处理了，引用变更包括:
   - 新增空间分配和引用变更，新增空间所有对象都认为是存活的。
   - 引用变更处理SATB(即三色标记的处理)

### 清理子阶段
&nbsp;&nbsp;该阶段也是需要STW的，清理子阶段主要完成:
1. 统计存活对象，利用RSet和BitMap来完成的，统计的结果将会用来排序HeapRegion，以用于下一次的CSet的选择；根据SATB算法，需要把新分配的对象，即不再本次并发标记范围内的新分配的对象，都视为活跃对象。
2. 交换标记位图，为下次标记准备
3. 重置RSet,此时老年代分区已经被标记完成，如果标记之后的分区没有引用对象，则说明引用已经改变，这时候可以删除原来的RSet里面的引用关系。
4. 把空闲分区放到空闲分区列表中，这里的空闲指的是全都是垃圾对象的分区，如果分区还有任何分区活跃对象都不会被释放，真正的释放是在混合GC里面。

## 参考资料
1. 004.OpenJDK(JVM)学习/009.GC/005.可达性分析算法.md  三色标记
2. 004.OpenJDK(JVM)学习/009.GC/008.G1/006.新生代回收-YGC.md