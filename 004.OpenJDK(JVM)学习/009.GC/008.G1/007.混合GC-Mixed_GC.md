# Mixed GC(混合GC)<sub>借助YGC结果，所以Mixed GC 一定发生在YGC之后</sub>
&nbsp;&nbsp;Mixed GC 既回收YHR也回收OHR,回收全部的YHR，回收部分的OHR;

## 那么是哪一部分的OHR呢?
&nbsp;&nbsp;G1 是如何对非空的，非完全满的垃圾区域是怎么处理的? 碎片是如何解决的? —— mixed GC
   所有Old区域包含一些活动对象，但是也有一些垃圾，把区域数除以8（-XX：G1MixedGCCountTarget=<>）,从这8份区域，依次从每一份中取出一个Region，将他放到CSet中，当在做YGC时，YGC有一个混合标志，所以不仅要接收和计数Eden区域。不止Eden 和 Survivor，还有1/8的Old区因为刚刚完成并发标记，这个算法和YGC是一样的，已经知道了哪些是活着的对象，并在对象树中浏览，将存活的对象复制到其他区域就行了——这就是G1压缩的方式：进入一个Old区域，移动所有的存活对象，把垃圾留下，然后这个特定的区域就可以被回收利用了。所以可以压缩存活对象 —— 取一些Old区域，然后将他们的存活对象复制到单个Old区域中，然后回收之前选择的Old区域
> G1MixedGCCountTarget 的意思是 当CSet Chooser 中Ｏld区数量占总old区数量小于1/G1MixedGCCountTarget时，就会执行Mixed GC,并在执行的过程中，还会继续添加Old区域到CSet Chooser中，然后再继续执行mixed GC。以此类推. 所以，mixed GC可能会发生多次，直到CSet中没有分区为止.

### 优先选择哪些Old区域进行Mixed GC
#### 1. 垃圾对象比例 >= G1MixedGCLiveThresholdPercent%(默认值:85)的优先
&nbsp;&nbsp;G1已经记录了每个区有多少个存活对象，首先复制上面所描述的"1/8"Old区域，首先瞄准的大部分是空的区域（<sup><font color="red">阈值： 85%,-XX:G1MixedGCLiveThresholdPercent=<>,即 85%(默认值)是垃圾，15%时存活对象</font></sup>)，因为如果只移动两个对象，那么这个特定区域就完成了，这很便宜，且回收了很多空间。
  
#### 2. 存活对象比例>=G1HeapWastePercent%(默认值:95)最后选择
&nbsp;&nbsp;G1也有浪费，当一个区域可能包含92%的存活对象，有8%的垃圾，此时，复制92%的存活对象会非常昂贵，所以不关心剩下8%的垃圾，甚至于不用考虑该区域，因为已经知道了他的收益非常小，代价非常昂贵。所以，你可以通过-XX:G1HeapWastePercent=<>告诉G1,可以浪费G1HeapWastePercent%的堆。


&nbsp;&nbsp;然后应用程序再次运行，然后在分配时再次运行，一个YGC被触发，然后在这时候，可以取第二个1/8的old区域,然后回收这第二个1/8,然后以此类推<sup>所以，Mixed GC可能会发生多次</sup>。越深入这8片区域就越难有效回收，当收集到了足够的区域，那么就会停止Mixed GC.
> 其实是 CSet 中老生代分区在CSet中比例超过1/G1MixedGCCountTarget,如果没有超过这个值，即使是预测时间超过了目标时间，仍然会添加老年代分区到CSet choosers中;如果预测时间达到了目标时间，到达最小值之后就不会再添加。

---

## Mixed GC 触发时机
1. 并发标记已经结束，更新好CSet Chooser，用于下一次CSet的选择
  ```txt
    并发标记发生在什么时候? 如下"并发标记子阶段"
  ```
2. YGC结束，判断是否可以进行混合回收，判断的依据:
  ```
    next_gc_should_be_mixed：
    当CSet Chooser中内存浪费>G1HeapWastePercent时，会进行mixed GC.
  ```

---

&nbsp;&nbsp;混合回收主要分为两个阶段:
1. 并发标记
   - **主要是将垃圾较多的老年代分区加入到CSet Chooser中**,
2. 垃圾回收
   - 这个过程和新生代回收的步骤完全一样，重用了新生代回收的代码。

## 第一阶段: 并发标记
&nbsp;&nbsp;并发标记的目的是为了识别老生代分区的使用情况，在下一次回收的时候优先选择垃圾比较多的分区进行回收。
### 初始标记子阶段
&nbsp;&nbsp;负责标记所有直接可达的根对象(栈对象、全局对象、JNI对象等)，根是对象图的起点，因此初始标记需要将Mutator线程暂停，也就是需要一个STW时间段.

&nbsp;&nbsp;混合收集中的初始标记和新生代的初始标记几乎一样。实际上混合收集的初始标记是借助了新生代收集的结果，即新生代垃圾回收后的新生代Survivor分区作为根，<font color="red">所以混合收集一定发生在新生代回收之后，且不需要再进行一次初始标记。</font>


### 并发标记子阶段
&nbsp;&nbsp;在YGC之后，如果发现满足并发标记的条件，并发线程就开始进行并发标记。根据新生代的Survivor分区以及老生代的RSet开始并发标记。并发的时机是在YGC后，只有达到InitiatingHeapOccupancyPercent阈值后，才会触发并发标记。InitiatingHeapOccupancyPercent默认值是45,表示的是当已经分配的内存加上即将分配的内存超过内存总容量的45%就可以开始并发标记。

### 再标记子阶段
&nbsp;&nbsp;再标记是最后的一个标记阶段，在该阶段中，G1需要引入一个暂停的时间，找出所有未被访问的存活对象，同事完成存活内存数据计算。引入该阶段的目的，是为了能够达到结束标记的目标，要结束标记的过程，需要满足三个条件:
1. 从根(Survivor)出发，并发标记子阶段已经追踪了所有存活对象。
2. 标记栈是空的
3. 所有的引用变更都被处理了，引用变更包括:
   - 新增空间分配和引用变更，新增空间所有对象都认为是存活的。
   - 引用变更处理SATB(即三色标记的处理)

### 清理子阶段
&nbsp;&nbsp;该阶段也是需要STW的，清理子阶段主要完成:
1. 统计存活对象，利用RSet和BitMap来完成的，统计的结果将会用来排序HeapRegion，以用于下一次的CSet的选择；根据SATB算法，需要把新分配的对象，即不再本次并发标记范围内的新分配的对象，都视为活跃对象。
2. 交换标记位图，为下次标记准备
3. 重置RSet,此时老年代分区已经被标记完成，如果标记之后的分区没有引用对象，则说明引用已经改变，这时候可以删除原来的RSet里面的引用关系。
4. 把空闲分区放到空闲分区列表中，这里的空闲指的是全都是垃圾对象的分区，如果分区还有任何分区活跃对象都不会被释放，真正的释放是在混合GC里面。

## 参考资料
1. 004.OpenJDK(JVM)学习/009.GC/005.可达性分析算法.md  三色标记
2. 004.OpenJDK(JVM)学习/009.GC/008.G1/006.新生代回收-YGC.md