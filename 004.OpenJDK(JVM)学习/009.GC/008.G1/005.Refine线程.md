# Refine线程
&nbsp;&nbsp;G1中引入了Refine线程，他实际上是一个线程池。有两大功能:
1. 用于处理新生代的抽样，并且在满足响应时间这个指标的情况下，更新新生代分区的数目，通常由一个单独的线程来处理。
2. 更新RSet
- 对于RSet的更新并不是同步完成的，G1会把所有的引用关系都先放到一个队列中(Dirty Card Queue,DCQ),然后使用Refine线程来消费这个队列完成引用关系的记录。正常来说有G1ConcRefinementThreads个线程处理，实际上除了Refine线程更新RSet之外，GC工作线程或者应用程序线程也可能会更新RSet.DCQ通过Dirty Card Queue Set(DCQS)来管理，为了能够快速、并发的处理，每个Refine线程只负责DCQS中某几个DCQ.

&nbsp;&nbsp;<font color="red">**RSet是为了记录对象在代际之间的引用**</font>,但是并不是所有代际之间的引用都需要记录。分区之间的应用关系可以归纳为:

|引用关系|是否需要记录|为什么|
|---|---|---|
|分区内部|不需要|回收是针对一个分区的，即这个分区要么被回收，要么不回收。如果回收，则会遍历整个分区。|
|新生代分区到新生代分区|不需要|G1的YGC/Mixed GC/FGC回收算法都会全量处理新生代分区，他们都会被遍历，因此无须记录|
|新生代分区到老年代分区|不需要|G1中的YGC针对的是新生代，无须知道这个引用关系；Mixed GC时，G1会使用新生代分区作为根，那么遍历新生代分区时自然能够找到新生代分区到老年代分区的引用，所以无须记录。|
|老年代分区到新生代分区|需要|在YGC时有两种根: 一个就是栈空间/全局变量的引用；一个是老生代分区的引用。|
|老年代分区到老年代分区|需要|在Mixed GC时可能只有部分分区被回收|

&nbsp;&nbsp;这里的引用关系指的是分区里面有一个对象存在一个指针指向另一个分区的对象。G1使用了RSet来记录所有的引用关系，单这并不是最优的设计方案。因为使用RSet进行回收实际上有两个重大的缺点:
1. 需要额外内存空间： 这一部分通常是JVM最大的额外开销，一般在1% ~ 20%
2. 可能导致浮动垃圾：由于根据RSet回收，而RSet里面的对象可能已经死亡，这个时候被引用对象会被认为是活跃对象，实际上他是浮动垃圾。

&nbsp;&nbsp;基于上述两点，有必要对RSet进行优化：
1. 通过垃圾回收的原理，可以判断哪些引用关系需要存放到RSet中。
--- 

## 开发选项
```c
   // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/gc_implementation/g1/g1_globals.hpp
     develop(bool, G1RecordHRRSOops,true,                    \
          "When true, record recent calls to rem set operations.")

     develop(bool, G1HRRSUseSparseTable, true,               \
          "When true, use sparse table to save space.")

     develop(bool, G1TraceHeapRegionRememberedSet,true,      \
          "Enables heap region remembered set debug logs")  
```
---
## 参考资料