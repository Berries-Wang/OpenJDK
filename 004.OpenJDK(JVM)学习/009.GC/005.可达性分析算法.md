# 可达性分析算法
&nbsp;&nbsp;通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明该对象是不可能再被使用的。
 - <img src="./pics/2022-01-12_21-30.png"/>
 -  + 如图，对象object5、object6、object7虽然由关联，但是他们到GC Roots是不可达的，因此他们将被判定为可回收的对象。

&nbsp;&nbsp;在Java中，固定可以作为GC Roots的对象包含以下几种:
1. 在虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 在方法区中类静态属性引用的对象
3. 在方法区中常量引用的对象
4. 在本地方法栈JNI引用的对象
5. Java 虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象(OOM、NPE)等，以及系统类加载器
6. 所有被同步锁(synchronized关键字)持有的对象
7. 反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调、本地代码缓存等。

&nbsp;&nbsp;除了这些固有的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象**“临时性”加入**，共同构成完整的GC Roots集合。如 Partial GC(部分收集)

## 根节点枚举
### 在枚举根节点时必须STW
&nbsp;&nbsp;至今，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问，根节点的枚举需要“Stop The World”。因为如果在枚举的过程中，根节点集合的对象引用关系还在不断的变化，那么分析的结果的准确性将无法保证。这是导致垃圾收集过程中必须停顿所有用户线程的其中一个重要原因。CMS、G1、ZGC等垃圾收集器在枚举根节点时也是必须要停顿的。

---
### GC Roots实现
&nbsp;&nbsp;目前主流JVM使用的都是准确式GC，所以当用户线程停顿下来之后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到那些地方存放着对象引用的。

&nbsp;&nbsp;在HotSpot中，使用了一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些消息了，不需要真正的从方法区等GC Roots开始查找。

---
## 安全点
&nbsp;&nbsp;在OopMap的协助下，Hotspot可以快速准确地完成GC Roots枚举.

&nbsp;&nbsp;导致OopMap内容变化的指令很多(引用关系变化)，如果为每一条指令都生成对应的OopMap,那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。

&nbsp;&nbsp;HotSpot也只是在“特定的位置”记录了这些信息，这些位置被称为安全点(SafePoint),有了安全点，也决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停

### 安全点的选取
&nbsp;&nbsp;因为用户线程在安全点需要停顿，因此，安全点的选取既不能太少以至于让收集器等待的时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点的选取基本上是以"是否具有让程序长时间执行的特征"为标准选定的。长时间执行针对的不是指令(指令是非常快的)，这里的长时间执行指的是指令序列的复用，如方法的调用、循环跳转、异常跳转等，所以只有这些功能的指令才会产生安全点。

### 用户线程如何在安全点停顿
&nbsp;&nbsp;如何在垃圾收集发生时，让所有的线程(执行JNI调用线程除外)都跑到最近的安全点，然后停顿下来。这里有两种方案:
#### 抢先式中断
&nbsp;&nbsp;抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让他一会再重新中断，直到跑到安全点上。
#### 主动式中断<sup>HotSpot的选择</sup>
&nbsp;&nbsp;当垃圾收集时，不直接对线程操作，仅仅简单的设置一个标识位，各个线程在执行的时候会不停地主动去轮询这个标识，一旦发现中断标识为真时就在自己最近的安全点上主动挂起。轮询标识的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够的内存分配新对象。

&nbsp;&nbsp;HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。如下，test指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把ox160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待。这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。
 ```log
     0x01b6d627: call   0x01b2b210      ; OopMap{[60]=Oop off=460}
                                        ; *invokeinterface size
                                        ; - Client1::main@113 (line 23)
                                        ;   {virtual_call}
     0x01b6d62c: nop                    ; OopMap{[60]=Oop off=461}
                                        ; *if_icmplt
                                        ; - Client1::main@118 (line 23)
     0x01b6d62d: test   %eax,0x160100   ;   {poll}
     0x01b6d633: mov    0x50(%esp),%esi
     0x01b6d637: cmp    %eax,%esi
 ```

---
## 安全区域
&nbsp;&nbsp;对于暂时没有获得CPU时间片的线程，无法执行到SafePoint，也无法在SafePoint处中断自己，VM也不可能持续等待线程重新被激活分配处理器时间。对于这种情况，VM引入了安全区域来解决。

&nbsp;&nbsp;安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域的任意位置开始垃圾收集都是安全的(可以将安全点理解为被拓展拉伸了的安全点),

&nbsp;&nbsp;当用户线程直行到安全区域里面的代码时，首先会标识自己已经进入到了安全区域中，那么当这段时间里虚拟机要发起垃圾收集时就不必管这些已声明自己在安全区域内的线程。当线程要离开安全区域时，他要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，那么继续执行；反之，他就需要一直等待，直到收到可以离开安全区域的信号。

---
## 附录
### 准确式GC
[深入理解Java虚拟机.pdf] 1.4.1 虚拟机始祖：Sun Classic/Exact VM
> Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Con-
servative/Accurate Memory Management）而得名。**准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型**。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一
个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类
型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提