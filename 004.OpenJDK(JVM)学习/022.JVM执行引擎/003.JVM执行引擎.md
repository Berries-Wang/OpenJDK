# JVM 执行引擎
> 先阅读:[揭秘Java虚拟机#第9章：执行引擎](./../../006.BOOKs/Unlocking-The-Java-Virtual-Machine/009.Unlocking-The-Java-Virtual-Machine-9.pdf) & [002.物理CPU-OS执行流程.md](./002.物理CPU-OS执行流程.md)

JVM 也完全继承了CPU（OS）的取指的设计思想： 通过明确定义操作码和操作数大小来计算下一条指令，从而完成取指操作。

JVM 作为一款虚拟机，有其一套指令集，这套指令集必定能够被JVM的虚拟运算器所识别，但是JVM并没有真正的硬件译码电路来识别JVM的这套指令，因此只能使用软件模拟。

字节码指令的宽度对于JVM虚拟机完成取指是至关重要的，JVM只有知道了每一个字节码指令所占的宽度，才能完成 "取指 -> 译码 -> 执行 -> 取指" 这种循环，将程序一直运行下去

### 字节码指令定义
> [005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/interpreter/bytecodes.cpp](../../005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/interpreter/bytecodes.cpp)
```c
/**
 * <pre>
 *      format 列记录了操作码和操作数的长度:
 *             b: 总长为1(字节)
 *             bc: 表示操作码后面会跟一个宽度为1字节的操作数,如bipush
 *
 *      ### Java的每个字节码指令都仅占一个字节 ###
 *
 *      ldc 整条指令，操作码和操作数一共只占2字节。
 *      ldc_w ,操作码和操作数一共只占3字节。
 *
 *   字节码指令的宽度对于JVM虚拟机完成取指是至关重要的，JVM只有知道了每一个字节码指令所占的宽度，才能完成
 * "取指 -> 译码 -> 执行 -> 取指" 这种循环，将程序一直运行下去
 * </pre>
 *
 * <pre>
 *     ldc: load constant
 *
 * </pre>
 */
void Bytecodes::initialize() {
  if (_is_initialized) return;
  assert(number_of_codes <= 256, "too many bytecodes");
  // ......
}
```