# 取指
> 先阅读:[揭秘Java虚拟机#第9章：执行引擎](./../../../006.BOOKs/Unlocking-The-Java-Virtual-Machine/009.Unlocking-The-Java-Virtual-Machine-9.pdf) & [002.物理CPU-OS执行流程.md](./../002.物理CPU-OS执行流程.md) & [JVM执行引擎](./README.md)了解取指逻辑

## JVM的两级取指机制
执行引擎的取指关键一步: 计算每一个指令的长度（不论是物理CPU还是JVM的软件模拟的执行引擎,内部核心机制都是一样的）

HotSpot以模板解释器来执行字节码。通过 [void TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out);](../../../005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/interpreter/templateInterpreter.cpp)函数来生成对应的机器指令, `该函数实现了指令跳转逻辑`<sup>即取下一条字节码指令</sup>

### 第一级取指机制 : 获取字节码指令 + 第二级取指机制 : 获取字节码对应的本地机器指令
```cpp
//    TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out)
//       void InterpreterMacroAssembler::dispatch_epilog(TosState state, int step);
//           void InterpreterMacroAssembler::dispatch_next(TosState state, int step); 
void InterpreterMacroAssembler::dispatch_next(TosState state, int step) {
  
  /**
   * load next bytecode (load before advancing r13 to prevent AGI)
   * 加载下一个字节码指令
   */
  load_unsigned_byte(rbx, Address(r13, step));

  /**
   * advance r13
   *
   * 取字节码指令
   *
   * r13 应该指向的是当前字节码指令所在的内存位置。即效果为 r13 = r13 + step
   *
   *  当JVM运行Java主函数main的时候，这时候根本不存在 上一条
   * 字节码指令，那r13指向那里呢? 答案在 generate_fixed_frame函数中：
   * generate_fixed_frame函数除了创建栈帧之外(
   * 在创建栈帧的过程中，JVM会将${字节码指令寄存器}寄存器指向main主函数的第一条字节码指令的内存地址)，
   * 还会调用dispatch_next函数执行Java的main主函数的第一条字节码指令
   */
  increment(r13, step);

  /**
   * 获取字节码指令对应的本地机器码指令
   */
  dispatch_base(state, Interpreter::dispatch_table(state));
}
```
