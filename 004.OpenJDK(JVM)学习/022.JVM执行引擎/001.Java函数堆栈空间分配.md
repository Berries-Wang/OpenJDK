# CalStub: 动态分配堆栈: Java函数堆栈空间分配
> 先阅读:[揭秘Java虚拟机#第二章](../../006.BOOKs/Unlocking-The-Java-Virtual-Machine/002.Unlocking-The-Java-Virtual-Machine-2.pdf)
>>　先弄清楚例程的概念、创建、存储

JVM为了能够调用 Java 函数，需要在运行期知道一个 Java 函数的入参大小，然后动态计算出所需要的堆栈空间 。 这就是JVM能够调用 Java 函数的`核心机制` 

JVM在执行Java函数调用时，仍然沿用了物理机器所使用的堆栈这一算法数据结构。因此，JVM仍然需要为Java被调用函数分配堆栈内存，保存被调用函数的空间大小，并动态为其分配堆栈空间。

`寄生`<sup>拓展别人的堆栈，存储自己所需要的数据</sup>: 由于物理机器不能识别Java程序，也不能直接执行Java程序，因此，JVM必然要通过自己作为一道桥梁<sup>JVM选择了 CallStub(StubRoutines::call_stub()) </sup>连接到Java程序，并让Java被调用的函数的堆栈能够“寄生”在JVM的某个函数的堆栈空间中，否则物理机器不会自动为Java方法分配堆栈。

## Java 函数参数传递
`Java函数的入栈操作——一切奥秘都在CallStub中`

Java函数的入参大小由Java编译器在编译期间计算出来。

JVM 内部对Java类型实例的访问全部通过指针来实现，访问Java类型实例的成员变量或方法时，也是基于指针偏移量获取对应的内存数据。
> 因此，Java函数传参，实际传递的只是指针： 在物理机器层面，不管何种数据类型的指针，其宽度都是相同的，指针的宽度只和物理机器的总线宽度有关，而与具体某种编程语言中的具体类型无关。
```txt
不管是char*类型的指针，还是int*类型的指针，还是自定义结构类型的指针，这些指针宽度完全相同：
- 在32位平台上，指针宽度一定是32位；
- 在64位平台上，指针宽度一定是64位；
```