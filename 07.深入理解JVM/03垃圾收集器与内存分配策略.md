# 垃圾收集器与内存分配策略
## 如何判断对象已死
### 可达性分析算法
+ 基本思路： 以一系列的GC Roots作为起点，从这些节点开始向下搜索，搜索所走过的路径就称为引用链(Reference chain)，当一个对象到GC Roots没有任何引用链相连(即图论中的不可达)时，则证明该对象是不可引用的。
+ `Java中，GC Root有哪些 ?`
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI（Native方法）引用的对象
## Java中的引用
+ JDK1.2之后对于Java引用的描述:---》当内存空间还足够时，则能保留在内存之中;如果内存空间在进行垃圾收集之后还是非常紧张，则可以抛弃这些对象。
### Java中引用
#### 强引用(Strong Reference)
+ 指在程序代码中普遍存在的，类似于 Object obj = new Object();这类的引用。只要强引用还存在，那么垃圾收集器就永远不会回收被引用的对象。
#### 软引用(Soft Reference)
+ 用于描述一些还有用但非必须的对象。对于软引用关联的对象，在系统将要发生内存泄漏之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。(即：收集器发现了它，但是这次并不回收，下一次GC时才会回收)
+ 用途
  - 缓存
  - ......
#### 弱引用(Weak Reference)
+ 用来描述非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**
+ 用途
  - 当想引用一个对象，但是这个对象有着自己的生命周期，又不想介入到这个对象的生命周期内，此时可以使用弱引用。
    + 例如：ThreadLocal
    ```java
    static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    ```
    将ThreadLocal保存为一个弱引用，这就要保证在外部需要保存一个ThreadLocal对象的强引用，否则就会造成ThreadLocal对象被回收，从而导致Value这个对象无法被回收，造成内存泄漏
#### 虚引用(Phantom Reference)
+ Java中最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来获取到一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
## 回收方法区
### JDK7
+ 回收的主要内容
  - 废弃常量
  - 无用类
+ 如何判定类是无用的
  - 该类的所有实例都被回收
  - 加载该类的ClassLoader已经被回收
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
+ `类并不与对象一样，不使用了就必然会回收。`是否对类进行回收，HotSpot提供了一系列的参数：
  - -Xnoclassgc  关闭虚拟机对class的垃圾回收功能。
  - -verbose:class 及 -XX:+TraceClassLoading 、 -XX:+TraceClassUnLoading  查看类加载卸载信息 
### JDK8
Jdk8中使用元空间替代了永久代，故类的信息回收方式取决于元空间的回收方式.即：
   + `类及相关的元数据的生命周期与类加载器的一致`
## 垃圾收集算法
`分代收集算法`
### 新生代
#### 算法
复制算法
### 老年代
#### 算法
标记 - 整理算法
标记 - 清除算法(CMS)
#### 分代收集算法
<div align=center><img src="./pics/Generational_collection.jpg"></div>

## 垃圾收集器
+ 准确式GC
  - HotSpot采用了准确式GC以提升GC roots的枚举速度。所谓准确式GC，就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。
+ 保守式GC
  -  在进行GC的时候，会从一些已知的位置（GC Roots）开始扫描内存，扫描到一个数字就判断他是不是可能是指向GC堆中的一个指针（这里会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针）之类的。）。然后一直递归的扫描下去，最后完成可达性分析。
    + 因为模糊搜索，所以会存在已死对象无法扫到的情况。
    + 针对保守式GC不能使用复制算法
      - 保守式GC不能使用复制算法原因在于当某个根为false point(非指针，可能是一个具体的值)时，对其指定的对象进行复制时将修改该根，但是该根其实质应该是具体的数值，这将导致程序异常。
### 枚举根节点
**STW(Stop The World)** 可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保`一致性`的快照中进行。`一致性`的意思就是在整个分析期间，整个执行系统就像被冻结在某一个时间点上，`不可以出现分析过程中对象的引用关系还在不断变化的情况`，这点不满足的话分析结果的准确性就无法得到保障。
+ 故 只要是GC，`就会涉及到STW`。那么就需要在开发的时候不要随意的申请内存，更多应该考虑内存的复用。
### 安全点
 + JVM并没有为每条指令都生成OopMap，只是在特定的位置记录这些信息，`这些位置就是安全点`
 + 在程序执行时并非在所有的地方都停下来GC，只有到达安全点才能暂停。
 + **OopMap**:记录哪些地方存放着对象，用来快速完成根节点的枚举(以空间换时间)
 + 安全点的选取:既不能太少，导致GC等待时间太长。也不能过于频繁导致过分增大运行时的负荷。故，安全点的选取应该是以`是否具有程序长时间执行的特征`为标准进行选定的。
#### GC时，如何让所有的线程均到安全点
+ 抢先式中断
  - 在GC发生时，首先将所有的线程全部中断，如何被中断的线程不在安全点上，就恢复线程，让线程执行到安全电上。
+ 主动式中断
  - 当GC需要中断线程时，仅简单地设置一个标识，各个线程执行时主动去轮询这个标识，发现中断标识为真时就自己中断挂起。`轮询标识的地方与安全点重合`，另外加上创建对象时需要分配内存的地方(应为OopMap)。
### 安全区域
当线程处于Sleep状态/Blocked状态时，无法响应JVM的中断请求。
+ 什么是安全区域?
  - 指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意位置开始GC都是安全的。
+ 如何标识线程进入了安全区域？
  + 在线程执行到安全区中的代码时，首先标识自己已经进入了安全区。那么在这段时间内GC时，就不用管这些线程了。在线程离开安全区域时，先要检查系统是否已经完成了根节点的枚举，如果完成了，那线程继续运行，反之，它必须等待直到收到可以离开安全区域的信号为止。
  + 那么在没有执行到安全区中的代码时该如何？ `觉得在线程进入了sleep/blocked状态后，其引用状态也就不会变化了。也就可以认为它们进入了安全区域。`
### 新生代垃圾收集器
#### Serial收集器
 单线程收集器，在他进行垃圾收集时，必须停止其他所有的工作线程。直到他收集结束.
 - 对于限定单个cpu的环境来说，该收集器没有线程交互的开销，专心垃圾收集，自然可以获得最高的单线程收集效率。
#### ParNew收集器
Serial收集器的多线程版本(同样，在进行垃圾收集是需要停止其他所有工作的线程、可用的控制参数、收集算法、Stop-The-World)、对象分配规则、回收策略等都与Serial一致)
+ 参数：
  - -XX:ParallelGCThreads 设置垃圾收集的线程数(默认与CPU的数量相同)
#### Parallel Scavenge 收集器
多线程收集器
+ 目标:达到一个`可以控制`的吞吐量
### 老年代垃圾收集器
#### Serial Old收集器
Serial 收集器老年版本，一个单线程收集器，使用"标记-整理"算法。主要用于Client模式下的虚拟机。在Server模式下，有两大用处：
  1. JDK1.5及其以前版本中与Parallel Scavenge收集器搭配使用
  2. 作为CMS收集器的后备，在并发收集Concurrent Mode Failure时使用。
#### CMS收集器（Concurrent Mark Sweep）
一种以获取最短回收停顿时间为目标的收集器，适用于互联网站或B/S系统的服务端上(重视服务响应速度，希望系统停顿时间最短，给用户较好体验)。使用`”标记-清除“`算法。整个过程分为4步:
   1. 初始标记(需STW)
   2. 并发标记
   3. 重新标记(需STW)
   4. 并发清除
+ 优点
  - 并发收集
  - 低停顿
+ 缺点
  - 对CPU资源敏感。在并发阶段，虽然不会造成用户线程停顿，但是会因为占用一部分CPU资源导致应用程序变慢。 
  - 无法处理浮动垃圾(`由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然会产生新的垃圾，这一部分的垃圾只能等到下一次GC再清理掉`)，可能出现Comcurrent Mode Failure(`CMS运行期间预留的内存无法满足程序需要`)失败导致另一次Full GC的出现。
    + 由于存在垃圾收集阶段用户线程还需要运行，那也就需要预留足够的空间给用户线程使用，故，CMS不能像其他的收集器那样等到老年代几乎被填满了在进行收集。jdk1.5默认当老年代使用到了68%就启动CMS。jdk1.6 CMS启动的阈值提升到了92%。参数 -XX:CMSInitiatingOccupancyFraction 可是设置启动阈值
  - 会产生大量的空间碎片(`因为使用了标记-清除`算法)。
     + 参数 -XX:+UserCMSCompactAtFullColection 开关参数(默认开启)，用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，这样解决了内存碎片的问题，但是停顿时间变长。

#### Perallel Old收集器
Parallel Scavenge 收集器老年版本，使用多线程和"标记-整理"算法.
## 内存分配与回收策略
### 对象优先在Eden分配
  `大多数`情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起以此Minor GC.
### 大对象直接进入老年代
大对象：需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。
+ 参数 -XX:PretenureSizeThreshold（单位：byte） ,令大于这个设置值的对象直接在老年代分配。
### 长期存活对象将进入老年代
对象在Survivor区中每熬过以此Minor GC，年龄就增加一岁，当他的年龄到达一定程度(默认15)，就将会晋升到老年代中。这个阈值可通过参数 -XX:MaxTenuringThreshold来设置
### 动态对象年龄判断
为了适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代。`如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间(一个)的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold所设定的阈值`
### 空间分配担保
在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生所有对象总空间，若大于，则Minor GC可以确保是安全的。反之，虚拟机会去查看HandlePromotionFailure设置值是否允许担保失败。若允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的对象的大小，若大于，将`冒险`尝试进行以此Minor GC;若小于，或者不允许冒险，则此时需要进行以此Full GC
  - 因为新生代使用复制算法，且只是用了一个survivor作为轮换备份，因此出现大量对象在Minor GC后依然存活的情况，需要老年代来进行分配担保，把survivor无法容纳的对象直接进入老年代。
## GC
### Full GC
+ 出现了Full GC，经常会伴随着至少一次的Minor GC.
老年代垃圾收集动作，速度慢。
+ 触发机制:
  - 调用System.gc
  - 老年代空间不足
  - 空间分配担保
  - Concurrent Mode Failure （CMS）
### Minor GC 
新生代垃圾收集动作，速度快。
+ 触发机制
  - 新生代满，指的是Eden
## 示例
+ [每日上亿请求量的电商系统，如何优化JVM年轻代垃圾回收参数？](https://www.toutiao.com/i6720898410179740171/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1566718854&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=2019082515405311106204904582889A77&group_id=6720898410179740171 "JVM内存合理分配") 