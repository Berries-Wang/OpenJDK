## 字节码指令
## 注意
1. Java是基于操作数栈解释执行的(解释执行方式)，对于JVM中的字节码指令来说，它是需要一个或者多个参数的。而这些参数是从操作数栈中获取的(从操作数的栈顶开始取)，但是需要注意的是，字节码指令在对操作数栈元素进行操作的时候，默认是存在一个出栈的动作的。即对于一个加法来说(iadd指令)，他会先将最靠近操作数栈栈顶的两个元素出栈，进行加法，最后将结果压入操作数栈
### 加载和存储指令
用于将数据在栈帧的局部变量表和操作数栈之间来回传输(局部变量表<==>操作数栈)
#### 将一个局部变量加载到操作栈
i表int，l表long，f表float，d表double，a表引用类型，n表示slot
+ iload:将指定的int型本地变量推送至栈顶
+ iliad_<n>
+ load: 将指定的long型本地变量推送至栈顶
+ load_<n>
+ fload:
+ fload_<n>
+ dload
+ dload_<n>
+ aload:将指定的引用类型本地变量推送至栈顶
+ aload_<n>:将第n个引用类型本地变量推送至栈顶
#### 将一个数值从操作数栈存储到局部变量表(规则桶load)
istore,istore_<n>,lstore,lstore_<n>........
#### 将一个常量加载到操作数栈
+ bipush ：将单字节的常量值(-128~127)推送至栈顶
+ sipush ：将一个短整型常量值(-32768~32767)推送至栈顶
+ ldc：将int, float或String型常量值从常量池中推送至栈顶
+ ldc_w：int, float或String型常量值从常量池中推送至栈顶（宽索引）   
+ ldc2_w ：将long或double型常量值从常量池中推送至栈顶（宽索引）
+ aconst_null：将null推送至栈顶
+ iconst_m1:将int型-1推送至栈顶
+ iconst_<i>
+ iconst_<l>
+ iconst_<f>
+ iconst_<d>
#### 扩充局部变量表的访问索引指令
wide

### 方法调用与返回指令
+ invokevirtual: 用于调用对象的实例方法，**根据对象的实际类型进行分派**(虚方法分派)
    - 根据对象的实际类型进行分派(第八章讲解)
+ invokeinterface: 用于调用接口方法，**他会在运行时搜索一个实现了这个接口方法的对象**，找出适合的方法进行调用
    - 运行时选择执行该方法的对象
+ invokespecial: 调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法
    - 三种特殊方法
       + 构造方法
       + 私有方法
       + 父类方法
+ invokestatic : 调用类方法
    -  static 修饰
+ invokedynamic: 用于在运行时动态解析出来调用点限定符所引用的方法，并执行该方法
  - 运行时解析过程
        1. 找到操作数栈栈顶的第一个元素所指向的对象的实际类型，记作C
        2. 若在类型C中找到与常量中的**描述符**和**简单名称**都相符的方法，则进行权限校验。若通过校验则返回这个方法的直接引用，查找过程结束;若不通过，则返回java.lang.IllegalAccessError异常
           + 注意：这里是根据描述符和简单名称进行匹配
        3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证的过程
        4. 若始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常
### 操作数栈管理指令
+ dup：复制栈顶一个或者两个数值并将复制值或双份的复制值重新压入栈顶