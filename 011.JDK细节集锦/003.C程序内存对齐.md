# C 程序内存对齐
## 什么是内存对齐
&nbsp;&nbsp;元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小（通常它为4或8）来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。

## 内存对齐的原因
### 1. 平台原因(移植原因)
&nbsp;&nbsp;不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

### 2. 性能原因
&nbsp;&nbsp;数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
   + 假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。
   + 现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

## 内存对齐规则
### 1. 基本类型
&nbsp;&nbsp;基本类型的对齐值就是sizeof值

### 2. 数据成员对齐规则
&nbsp;&nbsp;数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行;
  + 即：  将 "#pragma pack指定的数值" 和 “数据成员自身长度” 进行比较，取最小的那个

### 3. 结构(或联合)的整体对齐规则
&nbsp;&nbsp;结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行;
  + 即：  将 "#pragma pack指定的数值" 和 “最大数据成员长度” 进行比较，取最小的那个
---
## 附录
### 1. #pragma pack 是什么

---
## 参考资料
1.  https://zhuanlan.zhihu.com/p/140063999