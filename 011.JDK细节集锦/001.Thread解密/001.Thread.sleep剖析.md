# Thread.sleep 与 LockSupport#park
## 总结
&nbsp;&nbsp;Thread.sleep 相比于 LockSupport#park 是更耗费CPU资源的。
- pthread_cond_wait 暂停线程时，被暂停的线程不会耗费任何CPU资源
- pthread_cond_timedwait  存在性能问题，可能会造成CPU使用率过高。且会“虚假唤醒”(因为第二个参数是绝对时间，因此，如果调整系统时间产生虚假唤醒现象)


## 分析
&nbsp;&nbsp;探索Thread.sleep 与 java.util.concurrent.locks.LockSupport#park(java.lang.Object)之间的不同

### Thread.sleep
```java
       /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds, subject to
     * the precision and accuracy of system timers and schedulers. The thread
     * does not lose ownership of any monitors.
     * <p>
     * 根据系统计时器和调度器的精度和准确性，使当前执行的线程在指定的毫秒数内处于睡眠状态(暂时停止执行)。线程不会失去任何监视器的所有权。
     *
     * @param millis the length of time to sleep in milliseconds
     * @throws IllegalArgumentException if the value of {@code millis} is negative
     * @throws InterruptedException     if any thread has interrupted the current thread. The
     *                                  <i>interrupted status</i> of the current thread is
     *                                  cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;

    // 最终调用使用"os::sleep"来实现sleep逻辑( 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/prims/jvm.cpp#JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis));)


    // 通过代码探索，发现Thread.sleep 是调用函数 int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);来暂停线程的。man page信息如下:
       // atomically unlocks mutex and waits on cond, as pthread_cond_wait does, but it also bounds the duration of the wait. If cond has  not  been signaled  within the amount of time specified by abstime, the mutex mutex is re-acquired and pthread_cond_timedwait returns the error ETIMEDOUT.  The abstime parameter specifies an absolute time, with the same origin as time(2) and gettimeofday(2): an abstime of 0 corresponds to 00:00:00 GMT, January 1, 1970.

    // 通过源代码可知，Thread.sleep 底层调用逻辑如下:
    // pthread_mutex_lock -> pthread_cond_timedwait(等待指定时间，从而达到sleep功能) -> pthread_mutex_unlock
```

### LockSupport#park
&nbsp;&nbsp;该方法主要是通过调用“sun.misc.Unsafe#park”来实现的，因此，需要了解“sun.misc.Unsafe#park”方法的逻辑，该方法是native方法，对应的cpp代码:"005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/prims/unsafe.cpp"中。通过解读代码，可以发现，LockSupport#park通过如下C函数来调用的。
  ```c
    // 《UNIX 环境高级编程·第3版》
    // pthread man 手册安装 $: sudo apt-get install glibc-doc manpages-posix manpages-posix-dev
    // LockSupport#park : 调用顺序: pthread_mutex_trylock -> pthread_cond_wait
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
    // behaves identically to pthread_mutex_lock, except that it does not block the calling thread if the  mutex  is  already  locked  by  another thread (or by the calling thread in the case of a ``fast'' mutex). Instead, pthread_mutex_trylock returns immediately with the error code EBUSY.
    //  尝试对互斥量进行加锁，如果调用时互斥量处于未加锁的状态，则pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0.

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
    // pthread_cond_wait atomically unlocks the mutex (as per pthread_unlock_mutex) and waits for the condition variable cond to be signaled. The  thread  execution  is  suspended  and  does  not  consume  any  CPU  time  until  the  condition  variable  is  signaled.  The mutex must be locked by the calling thread on entrance to  pthread_cond_wait. Before returning to the calling thread, pthread_cond_wait re-acquires mutex (as per pthread_lock_mutex). 
    // 线程被暂停且不会消耗任何CPU
    // 调用者将锁住的互斥量传递给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量进行解锁。  这就关闭了条件检查和线程进行休眠状态等待条件这两个操作之间的时间通道，这样就不会错过条件的任何变化。 pthread_cond_wait返回时，互斥量再次被锁住.

    // LockSupport#unpark
    int pthread_mutex_lock(pthread_mutex_t *mutex);
    // locks  the given mutex. If the mutex is currently unlocked, it becomes locked and owned by the calling thread, and pthread_mutex_lock returns immediately. If the mutex is already locked by another thread, pthread_mutex_lock suspends the calling thread until the mutex is unlocked.
    // 对互斥量加锁，即加锁

    int pthread_cond_signal(pthread_cond_t *cond);
    // pthread_cond_signal  restarts  one of the threads that are waiting on the condition variable cond. If no threads are waiting on cond, nothing happens. If several threads are waiting on cond, exactly one is restarted, but it is not specified which.
    // 唤醒一个等待该条件的线程。


    int pthread_mutex_unlock(pthread_mutex_t *mutex);
    // unlocks the given mutex. The mutex is assumed to be locked and owned by the calling thread on entrance to pthread_mutex_unlock. If the mutex is of the ``fast'' kind, pthread_mutex_unlock always returns it to the unlocked state. If it is of the ``recursive'' kind, it decrements the locking count of the mutex (number of pthread_mutex_lock operations performed on it by the calling thread), and only when this count reaches zero is the mutex actually unlocked.
    // 对互斥量解锁，即释放锁
  ```

---

## 参考资料
1. OpenJDK1.8
2. 《UNIX 环境高级编程·第3版》