# synchronized 关键字解析
&nbsp;&nbsp;synchronized为JDK提供的同步机制，由JVM实现。内部具体是使用monitorenter、monitorexit 这两条JVM指令来实现的。通过学习，需要了解:
1. 基本原理
2. 偏向锁
3. 轻量级锁
4. 重量级锁的概念
5. 偏向锁->轻量级锁->重量级锁升级机制
6. 批量重偏向
7. java.lang.Object#wait() && java.lang.Object#notify 内部原理
8. ....

### 示例代码以及对应的字节码
```java
    // 源代码
    public class SynchronizedStu {
        public static void stuSynchronized() {
            synchronized (SynchronizedStu.class) {
                System.out.println("Hello World");
            }
        }
    }

    // 字节码
    public static void stuSynchronized();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=0
         0: ldc           #3                  // class link/bosswang/wei/SynchronizedStu  将该常量加载操作数栈。
         2: dup          // 复制栈顶一个元素，并将复制的值重新压入栈中
         3: astore_0     // 将一个数值从操作数栈存储到局部变量表。
         4: monitorenter  // 进入同步代码块
         5: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
         8: ldc           #5                  // String Hello World
        10: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        13: aload_0
        14: monitorexit   //  退出同步代码块
        15: goto          23
        18: astore_1
        19: aload_0
        20: monitorexit
        21: aload_1
        22: athrow
        23: return
      Exception table:
         from    to  target type
             5    15    18   any
            18    21    18   any
      LineNumberTable:
        line 9: 0
        line 10: 5
        line 11: 13
        line 12: 23
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 18
          locals = [ class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4
    }
```

&nbsp;&nbsp; synchronized 关键字是由JVM里面的monitorenter以及monitorexit字节码指令实现的，那么就通过这两个字节码指令来分析synchronized关键字的实现原理.

&nbsp;&nbsp;在继续之前，需要了解对象头相关内容:[004.OpenJDK(JVM)学习/004.类和对象/000.Oop-Klass二分模型.md](../../../004.OpenJDK(JVM)学习/004.类和对象/000.Oop-Klass二分模型.md)


### 一些重要的代码
```c
   // BasicObjectLock 即LockRecord
   // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/runtime/basicLock.hpp
```

### monitorenter
+ 文件: 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp (通过字节码解释器分析)

### monitorexit



### 偏向锁->轻量级锁->重量级锁升级机制
#### 偏向锁->轻量级锁
```txt
    1. 当锁对象处于偏向模式，但是系统没有开启偏向锁时
        // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp

        // 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/oops/klass.hpp
        -> _prototype_header 字段的注释
```

### 批量撤销/重偏向
```txt
    什么是重偏向/撤销？什么是批量重偏向/批量撤销?为什么需要批量重偏向/批量撤销?

   在什么时候发生批量偏向/撤销操作呢?
   -> 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/runtime/biasedLocking.cpp#update_heuristics(oop o, bool allow_rebias);
  
  为什么需要批量重偏向/批量撤销呢?

  撤销偏向
  -> 
  -> 

  什么是匿名偏向?
  -> 即锁对象处于偏向锁模式，但线程ID对应的线程不存在。那么什么情况会处于匿名偏向模式呢?
     1. 一般是因为java.lang.Object#hashCode被调用，导致hashcode被计算，从而导致无法使用偏向锁。(005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/runtime/biasedLocking.cpp:revoke_bias 来自函数内部代码注释)
        -> 具体定义可以查看函数:bool is_biased_anonymously();(005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/oops/markOop.hpp: 文件最开始的注释也有说明)
     2. 重偏向了
        -> 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/hotspot/src/share/vm/runtime/biasedLocking.cpp 搜索 “匿名偏向情况”
```