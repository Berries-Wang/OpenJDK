# 乐观锁<sup>无锁编程技术</sup>和悲观锁
&nbsp;&nbsp;在无锁状态下，如果想要协调线程对共享资源的获取，不需要对资源进行锁定，那么就不需要调用操作系统底层的同步原语，如mutex.这样就能大幅度减少操作系统内核态、用户态的切换，那么这样能在很多情况下极大提升多线程并发的性能。


## 悲观锁
&nbsp;&nbsp;悲观锁简单来说就是操作系统将会悲观地认为如果不严格同步线程调用，那么一定会产生异常，所以互斥锁会将资源锁住，仅供一个线程调用，而阻塞其他线程。但是有如下情况:
- 大部分都是读操作，那么就没有必要在每次调用时都锁定资源，或者在一些情况下，同步代码块执行的耗时远远小于线程切换的耗时。


## 乐观锁<sup>这是一种无锁的同步机制，并没有用到锁</sup>
### CAS（Compare  And Swap）
&nbsp;&nbsp;即线程每次都乐观的认为对象状态没有被其他线程修改过，而是每次自己都会主动尝试去compare状态值.

&nbsp;&nbsp;Java并没有直接使用CAS，CAS相关实现是借助C/C++调用CPU指令<sup>各个CPU架构都支持了原子性的CAS操作</sup>来实现的，效率很高，但Java代码需要通过JNI才能调用。例如：Unsafe提供的CAS方法

&nbsp;&nbsp;CAS 使用的CPU指令
  ```txt
      // 005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp
      // 005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp

      即: lock  、 cmpxchgq/cmpxchgl(不同版本的JDK所使用的命令不一样) 指令, 具体的请看注释
  ```

  ---

&nbsp;&nbsp;CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：

1. ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
   - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
2. 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
3. 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。
