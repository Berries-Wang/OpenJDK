# 乐观锁<sup>无锁编程技术</sup>和悲观锁
&nbsp;&nbsp;在无锁状态下，如果想要协调线程对共享资源的获取，不需要对资源进行锁定，那么就不需要调用操作系统底层的同步原语，如mutex.这样就能大幅度减少操作系统内核态、用户态的切换，那么这样能在很多情况下极大提升多线程并发的性能。


## 悲观锁
&nbsp;&nbsp;悲观锁简单来说就是操作系统将会悲观地认为如果不严格同步线程调用，那么一定会产生异常，所以互斥锁会将资源锁住，仅供一个线程调用，而阻塞其他线程。但是有如下情况:
- 大部分都是读操作，那么就没有必要在每次调用时都锁定资源，或者在一些情况下，同步代码块执行的耗时远远小于线程切换的耗时。


## 乐观锁<sup>这是一种无锁的同步机制，并没有用到锁</sup>
### CAS（Compare  And Swap）
&nbsp;&nbsp;即线程每次都乐观的任务对象状态没有被其他线程修改过，而是每次自己都会主动尝试去compare状态值.

&nbsp;&nbsp;CAS 使用的CPU指令
  ```txt
      // 005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp
      // 005.OpenJDK/001.openJdk8-b120/jdk-jdk8-b120/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp

      即: lock  、 cmpxchgq/cmpxchgl(不同版本的JDK所使用的命令不一样) 指令, 具体的请看注释
  ```
#### CAS原子性
&nbsp;&nbsp;各个CPU架构都支持了原子性的CAS操作。

#### 自旋
&nbsp;&nbsp;不断重试CAS操作。