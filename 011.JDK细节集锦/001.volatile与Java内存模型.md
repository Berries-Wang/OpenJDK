# Java内存模型 与 volatile
## 总结
1. 内存模型
2. Volatile
---
## Java内存模型
&nbsp;&nbsp;《Java虚拟机规范》定义了一种 “Java内存模型” 来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

### 主内存与工作内存
&nbsp;&nbsp;Java内存模型(JMM,Java Memory Model)的主要目的是定义程序中各种"变量"<sup>指实例字段、静态变量和构成数组对象的元素，但是不包括局部变量和方法参数，因为局部变量和方法参数是线程私有的，不会被共享，因此不会有竞争问题</sup>的访问规则：
  1. > 在虚拟机中把变量值存储到内存中
  2. > 从内存中取出变量值

&nbsp;&nbsp;为了执行性能，JMM没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。

#### >> 规定
1. >JMM规定了所有的变量都存储在主内存中，
2. >线程的工作内存中保存了该线程使用的变量的主内存**副本**
    - 线程对变量所有的操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。
    - 不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量的值的传递均需要通过主内存来完成**

#### 线程、工作内存、主内存关系示意图
- <img src="./pics/JMM-001.png"/>

##### 注意
1. 这里说的主内存与“堆、栈、方法区等”并不是同一个层次对内存的划分，这两者基本上没有任何的关系。

#### 内存间的交互
&nbsp;&nbsp;主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存中，如何从工作内存同步回主内存这一类的实现细节。

&nbsp;&nbsp;JMM内存模型定义了以下8种操作<sup>不是指令</sup>来完成，Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的<sup>double和long类型的变量特殊，该两类变量的load、store、read、write操作在某些平台上允许有例外</sup>
1. lock
   + >作用于主内存的变量，将一个变量标识为一条线程独占的状态(互斥锁定)
2. unlock
   + > 作用于主内存的变量，将一个处于锁定状态的变量释放出来，释放后的变量才能被其他变量锁定
3. read
   + >作用于主内存的变量，将一个变量的值从主内存传输到线程的工作内存中，便于随后的load动作使用
4. load
   + >作用于工作内存的变量，将read操作从主内存得到的变量值放入到工作内存的**变量副本**中
5. use
   + >作用于工作内存的变量，将工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时将会执行该操作
6. assign
   + >作用于工作内存的变量，将一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
7. store
   + >作用于工作内存的变量，将工作内存中一个变量值传送到主内存中，便于随后的write操作使用。
8. write
   + >作用于主内存的变量，将store操作从工作内存得到的变量值写入到主内存的变量中。

##### 交互示意图
- <img src="./pics/JMM-002.png"/>

---
## volatile(针对于valatil型变量的特殊规则)
&nbsp;&nbsp;volatile关键字是Java虚拟机提供的最轻量的同步机制。

&nbsp;&nbsp;Java内存模型为volatile专门定义了一些特定的访问规则，因此他具有两项特性：
### volatile 特性之 可见性
&nbsp;&nbsp;可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

>> 误区： “volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的”   >>> 这句话论据部分正确，但是结论并不正确
>>> 原因: volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算操作符并非原子操作<sup>问题1</sup>，这导致volatile变量的运算在并发下一样是不安全的
>>>> "问题1"原因: 一行Java代码可能对应多条字节码指令，一条字节码指令又可能需要执行引擎执行多行代码来实现。又或者是编译执行，一行Java代码也可能转换为若干条本地机器码指令。

#### 可见性注意事项
&nbsp;&nbsp;由于volatile只能保证可见性，在不符合如下两条规则的情况下仍然需要通过加锁来保证原子性: 

### volatile 特性之 禁止指令重排序