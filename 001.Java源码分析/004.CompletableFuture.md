# [CompletableFuture](../005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/jdk/src/share/classes/java/util/concurrent/CompletableFuture.java)



## 附录
### Treiber stack
&nbsp;&nbsp;The Treiber stack algorithm is a scalable<sup>可拓展的</sup> lock-free stack utilizing<sup>v.利用（utilize 的 ing 形式）</sup> the fine-grained<sup>adj.细粒的；有细密纹理的；详细的；深入的</sup> concurrency primitive<sup>n.（计算机）图元，原语</sup> compare-and-swap. It is believed that R. Kent Treiber was the first to publish it in his 1986 article "Systems Programming: Coping with Parallelism" (Treiber stack 算法是利用细粒度并发原语CAS实现的可拓展的无锁栈。)

#### Basic principle(基本原理)
&nbsp;&nbsp;The basic principle<sup>n.（机器等或自然界的）原理，定律；</sup> for the algorithm is to only add something new to the stack once you know the item you are trying to add is the only thing that has been added since you began the operation. This is done by using compare-and-swap. Pushing an item to the stack is done by first taking the top of the stack (old head) and placing it after your new item to create a new head. You then compare the old head to the current head. If the two are matching then you can swap old head to the new one, if not then it means another thread has added an item to the stack, in which case you must try again.(算法的基本原理是只有当你知道你要添加的项是自操作开始以来唯一被添加的项时，才会向堆栈中添加新内容。这是通过CAS来实现的。将一个项推入栈是通过首先取栈的顶部(旧头)并将其放在新项之后以创建新头来完成的。然后将旧头部与当前头部进行比较。如果这两个是匹配的，那么你可以交换旧的头到新的，如果不是，那么这意味着另一个线程已经添加了一个项目到栈，在这种情况下，必须再试一次)
```txt
    # 只有当你知道你要添加的项是自操作开始以来唯一被添加的项时，才会向堆栈中添加新内容 如何理解呢?
      1. 操作?什么操作? 操作指的是向栈中推入元素的操作。
      2. 唯一被添加?什么意思?此时栈中不能有元素？很明显不是，而是操作启动了，只有我这一个线程在向栈中推入元素，说的是在并发条件下会导致数据错乱。那么如何解决这个并发问题：通过CAS来实现。
         使用CAS之后，每次都会先读取栈顶元素，再通过CAS方式，去往栈中推入元素。那么就可以认为在推入操作开始后，只有当前这一个线程向栈中推入元素。
```

&nbsp;&nbsp;When popping an item from the stack, before returning the item you must check that another thread has not added a new item since the operation began. (当从栈中弹出一个元素时，在返回之前你必须校验自弹出动作开始是否有其他线程添加一个新的元素到栈中)
#### Correctness
&nbsp;&nbsp;In some languages—particularly, those without garbage collection—the Treiber stack can be at risk for the ABA problem. When a process is about to remove an element from the stack (just before the compare and set in the pop routine below) another process can change the stack such that the head is the same, but the second element is different. The compare and swap will set the head of the stack to the old second element in the stack mixing up the complete data structure. However, the Java version on this page is not subject to this problem, because of the stronger guarantees offered by the Java runtime (it is impossible for a newly created, unaliased object reference to be reference-equal to any other reachable object.) (在一些没有GC的语言中，Treiber stack有出现ABA问题的风险。当一个进程从栈中移除一个元素时另一个线程可能修改了这个栈,以至于他们的栈顶元素是一样的，但是第二个元素不一样。CAS操作将设置head为旧栈中的第二个元素从而混淆整个数据结构。然而，Java不受这个问题的影响，因为Java运行时提供了强有力的保障(新创建的未别名对象引用不可能与任何其他可访问对象的引用相等))
```en
    such that: 以至于
```

&nbsp;&nbsp;Testing for failures such as ABA can be exceedingly<sup>adv.非常，极其；</sup> difficult, because the problematic<sup>adj.成问题的，有困难的；未确定的</sup> sequence<sup>顺序;次序;</sup> of events is very rare<sup>adj.少见的，不常发生的；稀罕的，</sup>. Model checking is an excellent<sup>adj.极好的，卓越的</sup> way to uncover<sup>v.揭露，发现；揭开盖子，移开覆盖物；发掘，挖出</sup> such problems.  See for instance exercise 7.3.3 in "Modeling and analysis of communicating Systems".[3]
#### Example
&nbsp;&nbsp;Below is an implementation of the Treiber Stack in Java, based on the one provided by Java Concurrency in Practice
```java
          import java.util.concurrent.atomic.*;
          
          import net.jcip.annotations.*;
          
          /**
           * ConcurrentStack
           *
           * Nonblocking stack using Treiber's algorithm
           *
           * @author Brian Goetz and Tim Peierls
           */
          @ThreadSafe
          public class ConcurrentStack <E> {
              AtomicReference<Node<E>> top = new AtomicReference<Node<E>>();
          
              public void push(E item) {
                  Node<E> newHead = new Node<E>(item);
                  Node<E> oldHead;
          
                  do {
                      oldHead = top.get();
                      newHead.next = oldHead;
                  } while (!top.compareAndSet(oldHead, newHead));
              }
          
              public E pop() {
                  Node<E> oldHead;
                  Node<E> newHead;
          
                  do {
                      oldHead = top.get();
                      if (oldHead == null)
                          return null;
                      newHead = oldHead.next;
                  } while (!top.compareAndSet(oldHead, newHead));
          
                  return oldHead.item;
              }
          
              private static class Node <E> {
                  public final E item;
                  public Node<E> next;
          
                  public Node(E item) {
                      this.item = item;
                  }
              }
          }
```

## 参考资料
1. [CompletableFuture原理与实践-外卖商家端API的异步化](https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html)