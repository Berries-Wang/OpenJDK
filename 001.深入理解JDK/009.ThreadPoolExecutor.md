#　ThreadPoolExecutor
> 005.OpenJDK/002.OpenJDK8u312-GA/OpenJDK8U312-GA/jdk/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java


## 附录
### 1. 线程池大小设置
#### 线程池计算公式
```
    1. Ncpu = CPU的数量
    2. Ucpu = 目标CPU的利用率 , 0<= Ucpu <=1
    3. W/C  = 等待时间(Wait Time)与计算时间(Computation Time)的比率
    4. 为了保持处理器达到期望的利用率,最优的池的大小等于
       - Nthreads = Ncpu x Ucpu * (1 + W/C) = 线程数 = CPU可用核心数 * CPU利用率 / (1 - 阻塞系数），其中阻塞系数的取值在0和1之间。阻塞系数 = ${阻塞时间} /( ${阻塞时间} + ${计算时间} )。
```

+ CPU密集型: (n + 1) 或 （n - 1）
  - CPU密集即该任务需要大量的计算，而没有阻塞，CPU一直全速运行
  - CPU密集型任务尽可能少的线程数量，一般为CPU核数+1个线程的线程池
  - 为什么n+1
    > 计算密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。所以N+1确实是一个经验值。
  - 为什么 n - 1
    > 然后，每个线程池的线程数量，要考虑业务上下游，cpu，io资源使用的情况，来设计。很多线程池设计为cpu核数-1，例如Java 8之后jvm启动时默认会启动的ForkJoinPool.commonPool()，这个线程池执行forkjointask，高峰时很容易吃满cpu，属于计算密集型，这个情况下，最好设置为cpu核数-1，避免出问题时吃满cpu，导致其他业务完全无法运行，并且无法恢复以及定位问题

+ IO密集型 (2 * n)
  - IO密集型任务线程并不是一直在执行任务，可以尽可能多分配一点线程数，如 CPU数 * 2 , 也可以使用公式: CPU核心数 * (1+平均等待时间/平均工作时间)
    > 这是考虑IO是阻塞有延迟的，属于IO密集型，这样在IO阻塞，并且请求到达之间有延迟，每个线程都能充分运用

但是,还要考虑业务上下游，例如上游业务线程池个数，下游业务线程池个数，还有就是本身能使用的IO资源，例如数据库连接个数等等。
##### 示例
在一个请求中，计算操作需要5ms，DB操作需要100ms，对于一台8个cpu的服务器，该怎么设置线程数?
  1. 可以拆解为两个线程池来处理： 1个处理计算操作，设置 n + 1 =9个线程;一个线程池处理IO操作，设置2n=16个线程。
  2. 如果不能拆分怎么办?
     - a. 首先，这个任务整体算一个IO密集型任务，在处理一个请求的过程中，总共耗时 100 + 5 = 105ms , 而只有5ms是用于计算操作的，CPU的利用率为 5 / (100 + 5) .
     - b. 使用线程池是为了尽量提高CPU的利用率，减少对CPU资源的浪费，假设以100%的cpu利用率来计算，要达到100%的cpu利用率，那么根据计算公式，单个CPU设置的线程池大小=1 * 100% * (1 + 100/5)，那么该服务器有8个CPU，那么线程池大小=8*（1 * 100% * (1 + 100/5)） = 168
     - c. 但如果DB的QPS上限是1000,这个线程池又应该设置为多大呢?
     - d. 若按照186个线程的线程池计算，DB需要的QPS的数量= 1000 / (100 +5) * 168 = 1600
     - e. 但是，数据库无法承载1600的QPS，因此，需要缩减线程池的线程数量,因此，线程池的线程数量=168 * （1000/1600） = 105
     - f. 因此，当DB只能承接1000QPS时，线程池线程数量应该是105


## FAQ
1. 线程池如何知道一个线程的任务已经执行完成?
   - 通过钩子方法: java.util.concurrent.ThreadPoolExecutor#afterExecute 也可以判断子任务是否已经执行完成
   - 使用 `java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable)` 提交任务后，返回值是FutureTask，可以通过该futureTask.get方法的返回值来判断任务是否执行完成

## 参考资料
1. [Java并发编程实战  P141](../006.BOOKs/Java-Concurrent-Programming-Practices.pdf)